{"title": "微信小程序开发上传图片后缀名为unknow和getImageInfo的orientation不准的问题 ... ", "author": "Rolan", "pub_time": "2020-6-1 00:41", "content": "问题1:在云开发的存储中发现一些文件名为unknow，打开开发调试发现小程序chooseMedia拍摄图片后后缀名为unknow。在微信社群里搜索了相关信息官方表示这确实是一个bug。但是官方没有说明下次更新时间，而且这个bug前端也可以稍加修复。只需要判断后缀名是不是自己规定的并且设置一个默认的后缀名即可。getExt: function (filename,defaultExt) {\r\n    if(filename && filename.length > 3) {\r\n      const r = filename.split('').reverse().join(''); // 反转\r\n      const p = r.search(/\\./)\r\n      if(p > 2) {\r\n        // .unknown\r\n        const ext = r.substring(0,p).split('').reverse().join('');\r\n        if(['jpg','jpeg','png','mp4'].includes(ext)) {\r\n          return ext\r\n        }else{\r\n          return defaultExt\r\n        }\r\n      }else{\r\n        return defaultExt\r\n      }\r\n    }else{\r\n      return defaultExt\r\n    }\r\n  },问题2:getImageInfo的orientation不准一开始发现上传的图片很多方向都不对。就想到用canvas旋转一下图片。// 非要和国际标准不一样 不知道怎么想的\r\nconst orientations = {\r\n  up: 1,\r\n  'up-mirrored': 2,\r\n  down: 3,\r\n  'down-mirrored': 4,\r\n  'left-mirrored': 5,\r\n  right: 6,\r\n  'right-mirrored': 7,\r\n  left: 8\r\n}\r\n\r\n\r\nmodule.exports = async function (canvas,ctx,imgs) {\r\n  if(Array.isArray(imgs) && imgs.length) {\r\n\r\n    const tasks = []\r\n    for(const o of imgs) {\r\n      const promise = rotate(canvas,ctx,o).then(res=>{\r\n        return {...o,...res}\r\n      })\r\n      tasks.push(promise)\r\n    }\r\n    return await Promise.all(tasks)\r\n\r\n  }else{\r\n    return null\r\n  }\r\n}\r\n\r\nasync function rotate (canvas,ctx,o) {\r\n  console.log('rotate',canvas,ctx,o)\r\n\r\n\r\n  if(o.orientation === 'up') {\r\n    return {}\r\n  }\r\n\r\n  return await new Promise((resolve)=>{\r\n    const imgObj = canvas.createImage()\r\n    imgObj.src = o.tempFilePath\r\n    //imgObj.width = o.width\r\n    //imgObj.height = o.height\r\n    imgObj.onload = function (e) {\r\n      console.log('imgObj.onload')\r\n      let width = 0;\r\n      let height = 0;\r\n      let deg = 0;\r\n      const orientation = orientations[o.orientation]\r\n      console.log('orientation',orientation)\r\n      // 开始旋转逻辑\r\n      if ([2, 3, 6, 8, 4, 5, 7].includes(orientation)) {\r\n        if (orientation === 3 || orientation === 4) {\r\n          width = o.width;\r\n          height = o.height;\r\n          deg = 180;\r\n        } else if (orientation === 6 || orientation === 5) {\r\n          width = o.height;\r\n          height = o.width;\r\n          deg = 90;\r\n        } else if (orientation === 8 || orientation === 7) {\r\n          width = o.height;\r\n          height = o.width;\r\n          deg = -90;\r\n        }\r\n        // 利用canvas 进行旋转\r\n        canvas.width = width\r\n        canvas.height = height\r\n\r\n        console.log('reset canvas',canvas)\r\n\r\n        // 旋转canvas 并且 把图片放入canvas\r\n        ctx.translate(parseInt(width / 2, 10), parseInt(height / 2, 10));\r\n        if ([2, 4, 5, 7].includes(orientation)) {\r\n          ctx.scale(-1, 1);\r\n        }\r\n        ctx.rotate((deg * Math.PI) / 180);\r\n        ctx.drawImage(\r\n          imgObj,\r\n          0,\r\n          0,\r\n          o.width,\r\n          o.height,\r\n          0 - o.width / 2,\r\n          0 - o.height / 2,\r\n          o.width,\r\n          o.height\r\n        );\r\n\r\n        console.log('drawImage',imgObj)\r\n\r\n        wx.canvasToTempFilePath({\r\n          canvas,\r\n          fileType:'jpg',\r\n          quality: 0.5,\r\n          x: 0,\r\n          y: 0,\r\n          width,\r\n          height,\r\n          destWidth: width,\r\n          destHeight: height,\r\n          success(res) {\r\n            console.log('canvasToTempFilePath',res,width,height)\r\n            resolve({\r\n              width,\r\n              height,\r\n              tempFilePath: res.tempFilePath\r\n            })\r\n          },\r\n          fail(err) {\r\n            console.log('fail err',err)\r\n          },\r\n          complete(res){\r\n            console.log('com res',res)\r\n          },\r\n        })\r\n      }\r\n\r\n    }\r\n\r\n  }).then(res=>{\r\n    console.log('res2',res)\r\n    return res\r\n  })\r\n\r\n}以上是旋转并保持图片为本地临时文件的方法，由于微信开始自己出了一套canvas规则后来又废弃采用web标准版本的canvas，导致API文档新旧规则你中有我，我只有你。看完文档后通常就拿不定用哪一个方法如何开始了。微信自己实现的canvas drawImage 是支持临时文件的，而web标准版本的drawImage支持的是image对象的，在这个地方很多人都被官方带沟里了。当我实现canvas旋转图片后发现getImageInfo的orientation不准，让我无法判断用户选择的图片的orientation，从而导致了无法正确的旋转图片。后来经过各种资料查找发现getImageInfo只能判断原图的方向，知道这个问题就好办了，修改chooseImage文件类型为原图即可。"}
{"title": "小程序实战(二)-上传多图功能 ", "author": "Rolan", "pub_time": "2020-6-2 00:53", "content": "一、需求说明\r\n\r\n可选取相册照片，可拍照\r\n可选择压缩大小，可选择原图大小\r\n每次最多可选择 5 张图片\r\n\r\n二、需求实现\r\n2.1 选取照片实现\r\n通过调用小程序 api - chooseImage 来实现选取照片功能\r\n// 定义一个变量，用来存储用户选取的图片路径\r\nlet imagePaths\r\nwx.chooseImage({\r\n  count: 5,    // 限制每次最多选择 5 张\r\n  sizeType: ['original', 'compressed'],  // 可选择压缩大小，可选择原图大小\r\n  sourceType: ['album', 'camera'],   // 可选取相册照片，可拍照\r\n  success: res => {   // 选取图片成功的回调函数\r\n    imagePaths = res.tempFilePaths   // 存储选取的图片路径，是个数组\r\n  }\r\n})\r\n复制代码2.2 上传照片实现\r\n// 定义一个变量，用来存储上传成功的图片路径\r\nlet successPaths = []\r\n// wx.uploadFile 接口只能一次上传 1 张图片，所以需要先遍历\r\nimagePaths.forEach((path) => {\r\n  wx.uploadFile({\r\n    url: api.apiRootUrl + '/distribution/addPicture',   // 接口地址\r\n    filePath: path,\t// 当前图片路径\r\n    name: 'file',\r\n    header: { \"Content-Type\": \"multipart/form-data\" }, \r\n    success: res => {\t\t\t\t\t// 上传成功的回调函数\r\n      if (res.code == 200) {\r\n        successPaths.push(res.filePath)\r\n      } else {\r\n        this.showToast({\r\n\t\t\ttitle: res.msg\r\n\t\t  })\r\n      }\r\n      let filePaths = `formData.filePaths`\r\n\t\t// 存储上传成功的图片路径\r\n      this.setData({\r\n        [filePaths]: successPaths\r\n      })\r\n    }\r\n  })\r\n})\r\n复制代码2.3 图片预览实现\r\n<view wx:for=\"{{formData.filePaths}}\" wx:key=\"filePath\">\r\n\t<image src=\"{{filePath}}\"></image>\r\n</view>\r\n复制代码"}
{"title": "腾讯开心鼠英语 小程序实践与总结 ", "author": "Rolan", "pub_time": "2020-6-3 00:34", "content": "腾讯开心鼠英语 团队中有很多小程序的项目，且后续还会很多小程序的开发和迭代规划，因此我们团队是小程序的重度使用者。在小程序的开发中，团队积累了一些技术和经验，也遇到了一些困难和挑战，还踩了很多坑，因此有必要将我们团队的小程序实践进行总结和分享。一、工程化探索微信小程序的开发规范里，有一些工程方面的要求，例如可以通过项目的配置文件来设置根目录，每个页面或组件需要wxml、js、json、wxss 4个文件组成等，于此同时微信的开发者工具可以帮忙初始化项目，并设置好目录结构。除此之外对于项目工程方面的支持就比较薄弱了。为了提升团队的开发效率和质量，我们还需要在已有的基础之上进行一些列的优化。我们希望小程序的开发脚手架至少具备以下的能力：css预处理语言支持，可以使用例如sass、postcss等开发样式；typescript支持，可以更好地使用typescript进行开发；更好的目录结构设计；更好的npm包支持；代码检验支持，可以使用eslint/tslint、stylelint等对代码进行规制校验；因为现阶段的小程序开发的工程需求主要集中在文件编译和资源整理上，小程序开发者工具会帮我们处理文件打包，因此我们考虑使用gulp去搭建工程脚手架。1. 目录结构设计微信小程序的代码主要由4个放置在同一目录下的文件构成：.json 后缀的  JSON 配置文件；.wxml 后缀的  WXML 模板文件；.wxss 后缀的  WXSS 样式文件；.js 后缀的  JS 脚本逻辑文件；微信开发者工具会对以上的文件进行监听，当其中任意一个文件发生改变时，开发者工具就会刷新预览。如果使用ts进行开发，那在同一目录下，还将多出ts文件；如果参考这种方式引入css的预编译语言，那还会再多出一个待编译的样式文件。这样一个页面或组件的目录下，就至少会存在6个文件，显得非常臃肿，不仅降低了文件查找的效率，还有可能带来其他的误操作。因此这样的目录结构就不足以支撑我们后续开发的工程化要求。我们希望将源文件和编译文件分离，只保留基本的4种类型文件，当源文件发生改变时，就触发编译，将其编译成对应的开发者工具可以监听的文件类型。因此设计了以下新的目录结构：src 目录下存放项目的源文件，使用gulp监听文件的变化，并触发对应的编译任务，将源文件编译为目标文件，或者拷贝不需要编译的文件到目标目录（dist文件夹），然后在project.config.json里指定小程序的根目录为dist文件夹，这样开发者工具就会去监听dist目录里的文件变化并更新预览了。通过这样的设计，整个目录结构更加清晰，开发者只需要关注src目录即可。当然在实践的过程中，这样的目录结构也存在一定的问题：从文件变化到最后开发者工具更新预览的整个链路变长了，有一定的时间上的损耗；因为整个链路变长，也加大了引入其他问题的可能；因为一些历史原因，团队一些老的项目还没有完全按照这样的目录结构去设计，团队中的小程序项目目录结构还没有完全统一；以上的问题还需要我们团队在后续的开发中去解决和优化。2. css预处理语言支持微信小程序的样式代码主要是编写在wxss文件中，其语法和css是一样的，只有少量的css规则不适用。如果只是编写css样式，那只写wxss是完全没问题的。但是现在市面上还是有很多流行的css预处理语言可以帮助更好地开发css样式，提供了例如mixins、function、变量等功能。因此我们希望编写css预处理语言，并将其编译成wxss文件。我们团队使用的是postcss。源文件编写的是css文件，通过设置gulp task的方式，将css编译成wxss。并通过postcss插件的方式，集成更多的其他功能。在实践过程中，我们发现当项目规模开始变大时，在有些机器上，修改一次样式文件后触发更新的速度很慢，这个时候我们就引入cache去加速css的编译。第一次编译时会将所有的css编译，而后只会去编译修改过的文件。代码如下：/** * 将 css 编译成 wxss */const cssCompile = () =>  src([`${mpDir}/**/*.css`, `!${mpDir}/**/_*.css`])    .pipe(cache('css-compile'))    .pipe(      // 防止编译中断      postcss().on('error', () => {        this.emit('end');      })    )    // 去掉编译出来的 :root{}    .pipe(replace(/:root\\s\\{[^}]*\\}?\\s*/, ''))    .pipe(      rename((path) => {        path.extname = '.wxss';      })    )    .pipe(dest((file) => file.base));3. typescript支持原先的微信小程序对ts文件的支持，是通过预置编译脚本，使用 tsc 去编译ts文件的。我们的项目引入了gulp之后，对ts的支持就是通过设置gulp task，使用gulp-typescript 这个插件去编译ts文件，同时还需要使用gulp-sourcemaps这个插件去写入sourcemap。在实践过程中，我们发现有的时候ts的文件编译比较慢，这个时候可以使用gulp-typescript提供的增量编译的功能。开启增量编译之后，第一次编译时的速度是一样的，而之后的编译速度就会提升约50%。代码如下：const tsProject = ts.createProject(\"tsconfig.json\");// 编译 tsconst tsCompile = () =>  gulp    .src(tsPath)    .pipe(sourcemaps.init())    .pipe(      /* 增量编译 */      tsProject()    )    .js.pipe(sourcemaps.write())    .pipe(gulp.dest(dist));4. 更好的npm包支持微信小程序是支持使用npm包的，但是这个支持是有一些前提条件的。例如当引入某个包时：import { abcRequest } from '@tencent/abcmouse-sdk-mp-tools';小程序会去根目录下的miniprogram_npm这个文件夹下查找有没有@tencent/abcemouse-sdk-mp-tools这个包，如果没有则会提示找不到对应的包。而miniprogram_npm又是根据package.json里的dependencies字段里声明的依赖构建而成的。因此微信小程序要使用npm包的前提总结如下：必须在package.json的dependencies字段里有声明 ；小程序的根目录下必须有node_modules目录，其目录里有对应的包；必须构建出miniprogram_npm；因此要想使用npm包，整个过程是比较波折的。好在小程序官方有提供对应的ci构建可以帮助我们。但在实践过程中发现，调用ci.packNpmManually这个接口构建出来的miniprogram_npm目录，不仅包含了dependencies里的依赖，还包含了其他的依赖，而miniprogram_npm这个目录里的代码在上传小程序代码时也是会上传的，引入其他多余的依赖会增大小程序的包体积，在小程序严格的代码大小要求下，这是不可取的。因此还需要对构建的包进行筛选。其大致流程如下：使用gulp监听package.json文件，当安装新的npm包，并指定 --save 时，package.json文件会发生变化，并触发对应的gulp task。在gulp task里去遍历package.json的denpendcies字段，并从顶层目录的node_modules里拷贝对应的npm包放入dist目录的node_modules中。最后再通过ci.packNpmManually方法去构建，这个时候构建出来的miniprogram_npm目录里就只有必须的npm包了。通过这种方式，我们需要使用新的npm包时，就只需要npm install并在代码中import就可以了，其他的处理过程对开发者来说都是无感知的。相应的gulp task代码如下：/** * 在小程序根目录下生成package.json文件用于构建miniprogram_npm * @param {Array<string>} deps denpendencies对象 */const generateSubPkg = (deps) =>     writeJsonFile(subPkgPath, { dependencies: deps })    .then(() => deps);/** * 获取必要的npm包目录路径 * @param {Array<string>} deps 依赖数组 */const getDepsModule = (deps) =>     Object.keys(deps).map((key) => `node_modules/${key}`);/** * 构建miniprogram_npm * @param {Array<string>} modules npm包路径数组 */const packNpmManually = (modules) => {  const packPath = `${mpDir}/miniprogram_npm`;  const subNpmPath = `${mpDir}/node_modules`;  fsx.emptyDirSync(packPath);  fsx.emptyDirSync(subNpmPath);  modules.forEach((modulePath) => {    fsx.copySync(modulePath, `${mpDir}/${modulePath}`);  });  return ci.packNpmManually({    packageJsonPath: path.resolve(process.cwd(), subPkgPath),    miniprogramNpmDistDir: path.resolve(process.cwd(), mpDir),  });};/** * 构建miniprogram_npm gulp plugin */const packPkgManually = () =>  through.obj(function (chunk, enc, cb) {    const filepath = path.resolve(process.cwd(), 'package.json');    if (!fsx.pathExists(filepath)) {      cb(null, chunk);    }    const pkgData = fsx.readJSONSync(filepath);    const dependencies = pkgData.dependencies || {};    // denpendencies 没有发生变动则不需要构建    if (isEqual(cached, dependencies) || packing) {      cb(null, chunk);    }    const spinner = ora('开始构建npm包...').start();    packing = true;    generateSubPkg(dependencies)      .then(getDepsModule)      .then(packNpmManually)      .then((result) => {        cached = dependencies;        spinner.succeed('构建成功，构建结果:');        packing = false;        console.log(result);        cb(null, chunk);      })      .catch((err) => {        spinner.fail('构建失败');        packing = false;        console.error(err);      });  });const pkgPack = () => src(pkgPath).pipe(packPkgManually());const pkgWatch = () => {  watch(pkgPath, pkgPack);};5. 代码校验我们团队还接入了imweb团队的eslint和stylelint规则去做代码校验，这里就不具体暂开讲了，感兴趣的可以参考：eslint-config [ 1 ]；stylelint-config [ 2   ] ；6. 后续展望其实在小程序的工程化这一块还有很多工作可以做，例如：当项目体积变大时，小程序开发者工具的刷新预览速度变慢，除了等待小程序官方的优化之外，是否可以通过工程化的手段，提升开发者工具的预览刷新速度；合理的分包可以提升小程序的加载速度，是否可以通过工程化的手段，将项目中用到的通用组件，智能合理地分配到主包和子包中；引入命令行工具生成页面和组件的文件模板；尝试引入tree-shaking剔除无用的代码；尝试引入purifycss剔除无用的样式；集成官方的ci工具，完善开发体验；...我们团队会继续在小程序工程化方面进行探索和尝试，如果有新的成果我们也会及时分享。二、性能优化因为微信小程序是运行在微信app里的，所以其运行环境是比较苛刻的，因此要想使小程序流畅地运行，提供良好的用户体验，对其进行性能优化就至关重要。对于小程序优化来说，一些传统的前端优化方案也适用于小程序。而其双线程的设计模式，又和传统前端的单线程有所不同，因此也有一些新的优化点，下面主要从几个大的方面归纳总结：加快网络请求 ；加快页面渲染；提升渲染性能 ；内存优化 ；其他优化。1. 加快网络请求1.1 减小代码包大小小程序在冷启动时，会首先下载对应的代码包，然后解压执行代码，所以减小包大小可以加快代码下载和解压的速度。一些方法可以减小代码包的大小：代码复用，尽量将可以复用的代码提取封装做出npm包或通用函数；剔除无用的样式，可以使用类似 purifycss的库将无用的css样式剔除以减小样式代码的大小；剔除无用的函数，可以尝试引入tree-shaking剔除无用的代码；静态资源走cdn，尽量不要将静态资源打包到代码中；分包，可以将一些和首页渲染无关的代码分发到子包中从而加快主包的下载和执行。1.2 预请求数据预拉取：小程序提供了一个接口，可以让用户在进入到小程序之前就去请求接口，当然这个方法有一定的限制，需要深入调研和谨慎使用；分包预下载：可以配置进入某个页面时下载可能会用到的分包，可以有效避免进入某些页面”白屏“时间过长。1.3 缓存没有什么请求比不请求更快的了，合理利用缓存可以有效减少网络请求的数量，加快整体的加载速度。对于一些实时性不高的数据，我们可以利用微信提供的缓存能力，将一些数据存储在本地，从而避免一些网络请求。1.4 图片优化webp格式图片；图片剪裁和降质；图片懒加载和雪碧图；渐进式加载大图资源：在不得不使用大图资源的场景下，可以适当使用“体验换速度”的措施来提升渲染性能。小程序会把已加载的静态资源缓存在本地，因此，对于大图资源，我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <image> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。2. 加快页面渲染其实小程序的页面渲染的优化思路和传统前端的优化思路是一致的，主要思想是： 关键渲染路径渲染 ；关键渲染路径（Critical Rendering Path）是指完成屏幕渲染的过程中必须发生的事件。我们可以分析页面上哪些部分是主要模块，哪些部分是次要模块，例如一些提示性的组件，我们可以稍后渲染。于此同时，还可以在主要模块中还可以优先渲染主屏模块，不在主屏内的模块可以延迟加载或者滚动加载。3. 提升渲染性能提升渲染性能可以有效减少交互时的卡顿，让用户在交互的时候体验”如丝般流畅“。小程序采用的双线程模型，即渲染和逻辑分散在两个不同的线程中。所以在小程序的环境下，加快用户响应主要从以下3点出发：降低线程之间的通信频次；减少线程之间通信的数据量；减少wxml的节点数量。可以采用的办法有：合并setData调用；只把与界面渲染相关的数据放在data中；去掉不必要的事件绑定；去掉不必要的节点数据；事件总线管理数据；滚动渲染长列表节点；...4. 内存优化因为小程序毕竟是一个程序（微信）中的程序，可提供给其运行的环境资源是十分有限的，这对于小程序的设计和开发来说就比较苛刻了，因此要在实现的时候小心翼翼。可以从以下几个方面注意内存的优化：内存预警；回收后台页面计时器；避免触发事件中的重度内存操作；大图、长列表优化。5. 其他优化还可以采用一些其他的方式来对小程序进行优化：逻辑后移：可以让后台承担更多的业务实现。小程序端主要承担展示相关的职责，这样可以避免在小程序端进行过多的数据操作，占用过多的内存。也可以避免因为复制的业务实现而带来的潜在的程序崩溃；骨架屏：可以利用骨架屏来提升整体的加载体验。最后总结输出一下小程序性能优化相关的脑图如下：三、自动化探索1. 自动化测试小程序官方提供了自动化地工具去模拟小程序的操作，搭配常用的测试框架，可以很容易地实现小程序的前端测试。小程序的模拟器提供了4个级别的操作api：模拟器级别的 AutoMator；小程序级别的 MiniProgram；页面级别的 Page；元素级别的 Element。我们可以利用这几个api对象去模拟小程序的行为，例如模拟元素点击、页面数据修改、页面跳转等操作。具体api可以参考：小程序自动化工具 [ 3 ]。在实践接入的过程中遇到了一些坑。要想使用小程序模拟器是有一些前提条件的，首先是要开启开发者工具安全设置中的 CLI/HTTP 调用功能。并通过以下代码开启调用：automator.launch({  cliPath: 'path/to/cli', // 工具 cli 位置  projectPath: 'path/to/project', // 项目文件地址})其中 cliPath 是我们的开发者工具的文件路径，如果没有更改过默认安装的位置则可以忽略。projectPath是项目目录的地址，这里的项目目录指的是project.config.json里指定的目录，而且这个路径必须是绝对路径才可以调用成功。其次小程序的模拟器是有一些使用限制的，它不能调用和操作微信系统的原生组件的，例如授权、位置、支付等功能。当我们希望利用脚本去测试整个页面的流程时，当涉及到授权和支付等操作时，往往就跑不下去，因此小程序的模拟器更适合去做一些关键操作的测试，例如测试某些操作之后，页面的样式、行为是否符合预期。2. CI接入小程序的代码打包、上传等功能可以交由CI来操作。我们团队主要使用蓝盾CI，配合蓝盾上的小程序插件，可以很轻松地接入，其流程比较简单，主要是拉取代码、安装依赖和构建上传。蓝盾流水线如下：小程序代码上传需要用到秘钥，我们可以将其秘钥托管在蓝盾，即方便又安全。References[1] eslint-config:  https://github.com/imweb/eslint-config-imweb[2] stylelint-config:  https://github.com/imweb/stylelint-config-imweb[3] 小程序自动化工具:  https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/"}
{"title": "小程序工程化-环境变量配置管理 ", "author": "Rolan", "pub_time": "2020-6-3 00:11", "content": "引言\r\n我们在项目开发的过程中，会把环境分为开发环境、测试环境、生产环境等，社区里也有很多类似cross-env环境管理工具。但是在小程序的生态环境中，并没有成熟的解决方案来管理环境变量，开发者往往需要自己手动维护一些项目配置信息，这样做虽然没什么问题，但是随着项目的增大，要维护的配置信息可能会越来越多，我们很难保证不出错。下面我们将利用node的一些知识实现简单的环境变量配置管理。\r\n建立配置文件\r\n首先我们在项目根目录新建一个config文件夹，并在config文件夹下分别建立env/dev.json和env/prod.json等若干不同环境配置文件。分别放置该环境的配置信息，例如\r\n    // config/env/dev.json\r\n    {      \r\n        \"environment\":\"development\",\r\n        \"defaultURL\": \"https://dev.xxx.com/api/\"\r\n    }\r\n复制代码然后我们在根目录建立一个放置默认配置的projectConfig.js文件,并把它引入到app.js\r\n    // projectConfig.js\r\n    module.exports ={\r\n        \"projectname\": \"xxx\",\r\n    }\r\n    \r\n    // app.js\r\n    const config = require('./projectConfig')\r\n    App({\r\n        ...,\r\n        globalData: {\r\n         ...config\r\n        }\r\n    })\r\n复制代码这样子就完成了第一步：把配置信息引入到了我们的项目中。\r\n根据命令行，选择对应的env下的配置文件\r\n接下来在我们项目的package.json里scripts增加两条命令行,用来启动不同的环境\r\n    \"scripts\": {\r\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n        \"switch:dev\": \"node switch.js --dev\",\r\n        \"switch:prod\": \"node switch.js --prod\"\r\n    }\r\n复制代码在根目录建立switch.js，利用node.js处理配置信息\r\n/**\r\n * 根据命令行运行参数，修改/config.js 里面的项目配置信息，\r\n */\r\n\r\nconst fs = require('fs')\r\nconst path = require('path')\r\n//源文件\r\nconst sourceFiles = {\r\n  prefix: '/config/env/',\r\n  dev: 'dev.json',\r\n  prod: 'prod.json'\r\n}\r\n//目标文件\r\nconst targetFiles = [{\r\n  prefix: '/',\r\n  filename: 'projectConfig.js'\r\n}]\r\nconst preText = 'module.exports = '\r\n// 获取命令行参数\r\nconst cliArgs = process.argv.splice(2)\r\nconst env = cliArgs[0]\r\n// 判断是否是 prod 环境\r\nconst isProd = env.indexOf('prod') > -1 ? true : false\r\n// 根据不同环境选择不同的源文件\r\nconst sourceFile = isProd ? sourceFiles.prod : sourceFiles.dev\r\n// 根据不同环境处理数据\r\nfs.readFile(__dirname + sourceFiles.prefix + sourceFile,\r\n  (err, data) => {\r\n    if (err) {\r\n      throw new Error(`Error occurs when reading file ${sourceFile}.\\nError detail: ${err}`)\r\n      process.exit(1)\r\n    }\r\n    // 获取源文件中的内容\r\n    const targetConfig = JSON.parse(data)\r\n    // 将获取的内容写入到目标文件中\r\n    targetFiles.forEach(function(item, index) {\r\n      let result = null\r\n      if (item.filename === 'config.js') {\r\n        result = preText + JSON.stringify(targetConfig, null, 2)\r\n      }\r\n      console.log(result)\r\n      // 写入文件(这里只做简单的强制替换整个文件的内容)\r\n      fs.writeFile(__dirname + item.prefix + item.filename, result, 'utf8', (err) => {\r\n        if (err) {\r\n          throw new Error(`error occurs when reading file ${sourceFile}. Error detail: ${err}`)\r\n          process.exit(1)\r\n        }\r\n      })\r\n    })\r\n  })\r\n复制代码这样子当我们输入不同的命令行，动态的将相应环境配置信息写入默认配置文件，并引入到项目中。\r\n\r\n与开发者工具关联\r\n每次切换环境都要自己运行npm脚本，也会有点不方便，这个时候我们可以配置开发者工具\r\n在开发者工具的本地设置中，勾选启用自定义处理命令，并分别在编译前预处理和上传前预处理填入我们的命令\r\n\r\n这样子就保证了开发环境和生产环境隔离，避免产生脏数据。\r\n写在最后\r\n欢迎大家关注我的公众号：前端Readhub 。"}
{"title": "Taro 1.0系列：taro build原理分析 ", "author": "Rolan", "pub_time": "2020-6-3 00:51", "content": "众所周知， taro-cli 是Taro脚手架初始化和项目构建的的命令行工具，它的实现原理，相信大家从 Taro 技术揭秘：taro-cli 这篇文章中已经有所了解；本文将对其中的项目构建 build 命令进行分析，从 cli 层面了解 taro 构建的过程到底做了什么；build命令的注册在执行 npm install -g @tarojs/cli 时， npm 通过读取 package.json 文件中的 bin 字段，将 taro 这个命令注册到 [prefix]/bin 中作为全局命令；如果在当前项目目录下，执行 npm install @tarojs/cli ，则会将taro这个命令注册到 ./node_modules/.bin/ 底下作为本地命令；// package.json\r\n\"bin\": {\r\n  \"taro\": \"bin/taro\"\r\n}由于 npm config get prefix 为 /usr/local ，所以全局命令将会被注册到 /usr/local 目录底下，通过 symlink 符号链接的方式，使得 /usr/local/bin/taro 指向 /usr/local/lib/node_modules/@tarojs/cli/bin/taro ；bin/taro 文件作为 taro-cli 的入口，内部使用 commander.js 来解析命令中的参数，并且支持 git 风格的子命令处理，可以根据子命令自动引导到 [command]-[subcommand] 格式命名的执行文件；所以当执行 taro build 命令时，则被 commander.js 自动引导到 bin/taro-build 文件下，继而执行 bin/taro-build 的逻辑；build命令的分发taro build 命令功能非常多，它能够支持：1、构建 H5 ；taro build --type h52、构建小程序及小程序插件，支持 weapp/swan/alipay/tt/qq/jd 类型；// 小程序\r\ntaro build --type weapp\r\n// 小程序插件\r\ntaro build --plugin weapp3、构建UI库；cross-env TARO_BUILD_TYPE=component taro build --uitaro-build 接收 --type 参数的值，接收到的结果交由 dist/build.js 的 build 函数进行判断，通过判断不同 type 的值，决定执行对应平台构建类型的逻辑，例如，当 --type 为 h5 时，则执行 dist/h5/index.js 文件中 build 函数的逻辑；当 --type 为 weapp 时，则执行 dist/mini/index.js 文件中 build 逻辑；h5的构建逻辑h5 的构建流程主要经过： 源代码 => 中间代码 => 目标代码 的转换； 其中：源代码：一般是指 src 目录底下的代码，如果 config 中有配置 sourceRoot ，则源代码入口就为 sourceRoot ；中间代码：指 .temp 目录下的代码，由 taro-build 实现的中间流程，主要通过 babel 实现中间代码的转换和生成；目标代码：指最终运行在浏览器的代码，一般指 dist 目录下的代码，如果 config 中配置 outputRoot ，则目标代码将输出在 outputRoot ；所以，三种代码间的转换关系可以用下图表示：taro-build 帮助将源代码转换成中间代码，并保存在 .temp 文件夹中，中间代码再交由 webpack 进行打包构建生成目标代码；中间代码的生成为什么会有中间代码生成这个步骤呢，这是因为：直接将 源代码 交由 webpack 进行编译，会出现部分方法的缺失、页面无法找到等的问题；Taro 需要根据构建平台的类型进行一系列的 转换 ，并导入对应平台的核心包；还需要根据工程或者页面的 config 对 源代码 进行转换，并插入一些 关键代码 ；中间代码的生成流程需要转换的代码主要以 src 目录下的代码为主，而且只分析和转换js和ts的文件，因为涉及到代码的分析，所以借助了 babel 工具链，例如 babel-core 、 babel-traverse 、 babel-types 和 babel-template 等核心包中的方法进行处理，主要流程如下：1、区分是否为 js或ts ，是则进行分析，否则直接复制；2、分析文件是否为 ENTRY文件 ， PAGE文件 ， NORMAL文件 ，分类完成，则交由对应的处理函数进行处理；3、处理解析 ENTRY文件 ；4、处理解析 PAGE文件 和 NORMAL文件 ；5、处理完后的代码生成到 .temp 文件夹中；6、调用 webpack-runner ，对 .temp 文件的代码进行处理，生成到 dist 文件夹中；ENTRY文件的分析ENTRY类型 的文件，由 processEntry 函数处理，通过 babel-traverse 中的traverse方法对不同类型的AST节点进行分析，其中涉及到很多细节，主要流程如下：1、解析 config 这个 ClassProperty 节点的内容，获取 pages 和 subPages ;2、依赖纠正：主要转换 tarojs/taro 、 tarojs/mobx 、 tarojs/redux 相关依赖为 tarojs/taro-h5 、 tarojs/mobx-h5 、 tarojs/redux-h5 ；转换 ImportDeclaration 节点中的 alias 别名；引入 Nervjs 核心包；3、在 render 函数中，加入页面的 Router 组件(根据 pages 和 subPages )， Provider 组件， Tabbar 组件；4、引入 taro-router 相关代码；PAGE文件和NORMAL文件的分析PAGE类型 和 NORMAL类型 的文件，由 processOthers 函数处理，也是通过 babel-traverse 中的traverse方法对不同类型的AST节点进行分析，这里只列出主要流程：1、依赖纠正：主要转换 tarojs/taro 、 tarojs/mobx 、 tarojs/redux 相关依赖为 tarojs/taro-h5 、 tarojs/mobx-h5 、 tarojs/redux-h5 ；转换 ImportDeclaration 节点中的 alias 别名；引入 Nervjs 核心包；2、解析 config 这个 ClassProperty 节点的内容，获取配置项，对页面添加相关的组件和函数，例如 PullDownRefresh 组件和 onPageScroll 方法;3、导出纠正：当前类的 nameExport 纠正为 defaultExport ，例如：当前文件 page-index.js// 纠正前\r\nexport class PageIndex extends Component {\r\n  ...\r\n}\r\n\r\n// 纠正后\r\nclass PageIndex extends Component {\r\n  ...\r\n}\r\n\r\nexport default PageIndex;4、声明纠正：当前 ClassExpression 或 ClassDeclaration 中，在没有 identifier 的情况下，添加默认的 identifier 为 _TaroComponentClass ：// 纠正前\r\nexport default class extends Component {\r\n  ...\r\n}\r\n\r\n// 纠正后\r\nexport default class _TaroComponentClass extends Component {\r\n  ...\r\n}webpack-runner逻辑中间代码生成后，缓存在 .temp 文件夹底下，并且作为 webpack-runner 的入口文件， taro-build 在完成 buildTemp 的流程后，就会继续执行调用 webpack-runner 的逻辑； webpack-runner 的逻辑实际上就是根据定义好的 webpack 的配置，生成目标代码的流程，后面将会有单独的一篇文章详述相关配置，这里不做再多的描述；小程序的构建逻辑taro-build 的小程序构建逻辑不存在中间代码的生成，而是直接由 源代码 生成小程序能运行的 目标代码 ；这里的源代码是指遵循 React 规范的taro代码，这种代码在小程序的容器中是无法直接运行的，所以需要通过 taro-build转换 成小程序可运行的代码，因此在这个流程中涉及大量的 AST语法解析和转换 ；小程序的构建流程主要分三步完成(当然这里还有很多细节，但本文暂不详细阐述)：构建入口：指构建 sourceDir 指定的文件，默认是 app.jsx 文件，构建的逻辑由 buildEntry 函数完成；构建页面：指构建在 app.jsx 文件中的 config.pages 配置好的页面文件，主要由 buildPages 函数完成；构建组件：指构建页面文件中依赖的组件，主要由 buildSingleComponent 函数完成；构建流程需要依赖 taro-transformer-wx 包去解析 JSX 语法，已经对源代码的 AST语法树 ，进行代码插入和转换；buildEntry逻辑构建入口的逻辑大概如下：1、调用 taro-transformer-wx 中的 wxTransformer 方法转换 JSX语法 ；2、将 app.jsx 中的 es6 语法通过 babel 转换为 es5 ，并且引入 taro-weapp 核心包；3、通过AST转换，插入调用 taro-weapp 包中 createApp 函数的语句；4、生成 app.json 、 app.js 、 app.wxss 文件；buildPages逻辑构建页面的逻辑大概如下：1、调用 taro-transformer-wx 中的 wxTransformer 方法转换 JSX语法 ；2、将页面js中的 es6 语法通过 babel 转换为 es5 ，并且引入 taro-weapp 核心包；3、通过AST转换，插入调用 taro-weapp 包中 createComponent 函数的语句；4、编译页面所依赖的组件文件，由 buildDepComponents 函数实现；5、生成页面对应的 page.json 、 page.js 、 page.wxss 、 page.wxml 文件；buildComponent逻辑构建组件与构建页面类似，但多了递归的步骤，其逻辑大概如下：1、调用 taro-transformer-wx 中的 wxTransformer 方法转换 JSX语法 ；2、将组件js中的 es6 语法通过 babel 转换为 es5 ，并且引入 taro-weapp 核心包；3、通过AST转换，插入调用 taro-weapp 包中 createComponent 函数的语句；4、 递归 编译组件所依赖的组件文件，由 buildDepComponents 函数实现；5、生成页面对应的 page.json 、 page.js 、 page.wxss 、 page.wxml 文件；taro-transformer-wxtaro 将 JSX 解析到小程序模板的逻辑，单独拆成一个包 taro-transformer-wx ，里面涉及到大量的AST解析和转换，本文由于篇幅的关系，暂时不详细分析，希望后面会有单独的文章去分析 小程序AST转换的流程 ，敬请期待；结语总的来说，从 cli 层面去看taro的构建流程，会发现为了兼容多平台，taro会使用较多的 AST解析和转换 ，帮助将 React 规范的taro代码转换到对应平台能够运行的代码；这里也告诉我们，作为一个前端er，学习和掌握 AST 相关知识，能让你看到更大的世界！最后，本文作为一篇原理分析的文章，如有疏漏以及错误，欢迎大家批评指正！"}
{"title": "小程序实战(三)-生成二维码海报 ", "author": "Rolan", "pub_time": "2020-6-3 00:52", "content": "一、需求说明\r\n\r\n点击生成海报\r\n海报有二维码\r\n点击保存 可将海报保存到手机相册\r\n\r\n二、需求实现\r\n2.1 总体实现方式\r\n这个需求的核心路径就是：\r\n获取到图片路径 -> 使用 canvas 画图 -> 将 canvas 画布转换为 url -> 将该图片存储到手机相册\r\n其中，各个步骤的实现方式如下：\r\n\r\n\r\n获取到图片路径：\r\n若是本地图片，可直接使用相对路径，如 '/images/poster-bg.png'\r\n若是网络图片，或接口返回的图片，则需要先将图片下载到本地，获取到图片的路径，再使用。可使用 wx.getImageInfo实现\r\n\r\n\r\n使用 canvas 画图：\r\n在小程序中使用 canvas 与在正常 web 项目中不同。\r\n正常项目中这样使用：\r\n\r\n\r\n<canvas id=\"canvas-container\"></canvas>\r\n复制代码let canvas = document.getElementById('canvas-container')\r\nlet ctx = canvas.getContext()\r\n// 接下来使用 ctx 的 api 进行绘图\r\n复制代码而在小程序中，是无法直接使用 document.getElementById 这样的 api 操控 dom。因此，需要使用小程序专门提供的 api，用法如下：\r\n<canvas canvas-id=\"canvas-container\"></canvas>\r\n复制代码let ctx = wx.createCanvasContext('canvas-container')\r\n// 接下来使用 ctx 的 api 进行绘图\r\n复制代码\r\n\r\n将 canvas 画布转换为 url\r\n使用微信提供的 api，将完成的画布转换为 url：wx.canvasToTempFilePath\r\n\r\n\r\n将该图片存储到手机相册\r\n使用微信提供的 api，将图片保存在手机相册：wx.saveImageToPhotosAlbum\r\n2.1 获取到图片路径\r\n\r\n\r\n海报背景图\r\n背景图片直接放进了代码的静态资源文件夹里。直接使用相对路径即可\r\n\r\n\r\n二维码\r\n二维码需要调用后端接口获得，并下载到本地获取临时路径。\r\n调接口获取二维码路径并保存：\r\n\r\n\r\ngetPosterImage() {\r\n\twx.showLoading({\r\n    title: '正在制作海报。。。'\r\n  })\r\n\tlet that = this\r\n\tpost(api.getQRImage).then(res => {\r\n\t  this.setData({\r\n\t    qrImageUrl: res.path\r\n\t  })\r\n\t  this.getImageInfo()\r\n\t})\r\n}\r\n复制代码由于网络图片或接口返回图片，无法直接使用，需要下载到本地获取临时路径：\r\ngetImageInfo() {\r\n\tlet that = this\r\n\twx.getImageInfo({\r\n\t\tsrc: this.data.qrImageUrl,\r\n\t\tsuccess: res => {\r\n\t\t\tthat.drawPoster(res.path)\r\n\t\t}\r\n\t})\r\n}\r\n复制代码2.2 使用 canvas 画图\r\n\r\n增加 canvas 标签，设置为不可见\r\n\r\n<!-- 通过 isShowPoster 控制画布是否显示 -->\r\n<!-- 设置画布宽高 -->\r\n<canvas canvas-id=\"poster-canvas\" class=\"{{isShowPoster ? '' : 'no-display'}}\" style=\"width:{{windowWidth}}px;height:{{posterHeight}}px;\"></canvas>\r\n\r\n<!-- 保存海报按钮，通过 isShowPoster 控制是否显示 -->\r\n<button class=\"{{isShowPoster ? '' : 'no-display'}}\" bindtap=\"handleSavePoster\">保存海报</button>\r\n复制代码\r\n通过屏幕尺寸计算画布尺寸：\r\n\r\nonLoad: function (options) {\r\n\t  // poster 的宽和高依据拿到的背景图宽高为准\r\n    const poster = {\r\n      \"with\": 375,\r\n      \"height\": 587\r\n    }\r\n\t  // 获取设备宽高信息 画布宽度等于屏幕宽度，画布高度按比例计算\r\n    const systemInfo = wx.getSystemInfoSync()\r\n    let windowWidth = systemInfo.windowWidth \r\n    let windowHeight = systemInfo.windowHeight\r\n    let posterHeight = parseInt((windowWidth / poster.with) * poster.height)\r\n    this.setData({\r\n      windowWidth: windowWidth,\r\n      posterHeight: posterHeight\r\n    })\r\n  }\r\n复制代码\r\n获取 canvas context 实例：\r\n\r\n<canvas canvas-id=\"canvas-container\"></canvas>\r\n复制代码drawPoster() {\r\n\tlet ctx = wx.createCanvasContext('canvas-container')\r\n}\r\n复制代码\r\n使用 ctx 实例的 api 绘图：\r\n\r\ndrawPoster() {\r\n\tlet windowWidth = this.data.windowWidth\r\n  let posterHeight = this.data.posterHeight\r\n\tlet ctx = wx.createCanvasContext('canvas-container')\r\n\t// 绘制背景图\r\n\tctx.drawImage(this.data.backgroundUrl, 0, 0, windowWidth, posterHeight, 0, 0);\r\n\t// 绘制二维码 \r\n\t// x坐标为 (画布宽度 - 二维码宽度) / 2\r\n\t// y坐标为 (画布高度 - 二维码高度 - 底部距离) \r\n  ctx.drawImage(this.data.qrImageUrl, (windowWidth - 60) / 2, posterHeight - 70, 60, 60, 0, 0);\r\n\t// 绘图\r\n\tctx.draw()\r\n\r\n\t// 将画布设置为可见\r\n\tthis.setData({\r\n  \tisShowPoster: true\r\n\t})\r\n\twx.hideLoading()\r\n}\r\n复制代码2.3 将 canvas 画布转换为 url\r\nhandleSavePoster() {\r\n    wx.showLoading({\r\n      title: '正在保存海报。。。'\r\n    })\r\n    let that = this\r\n    setTimeout(function() {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: that.data.windowWidth,\r\n        height: that.data.posterHeight,\r\n        destWidth: that.data.windowWidth,\r\n        destHeight: that.data.posterHeight,\r\n        canvasId: 'poster-canvas',\r\n        success: function (res) {\r\n          that.setData({\r\n            posterUrl: res.tempFilePath,\r\n          })\r\n          that.saveImageToAlbum()\r\n        }\r\n      })\r\n    }, 500)\r\n  }\r\n复制代码2.4 将该图片存储到手机相册\r\nsaveImageToAlbum() {\r\n    let that = this;\r\n    //将图片保存到相册       \r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: that.data.posterUrl,\r\n      success(res) {\r\n        wx.hideLoading()\r\n        wx.showModal({\r\n          title: '保存成功',\r\n          content: '图片成功保存到相册了，快去分享朋友圈吧',\r\n          showCancel: false,\r\n          confirmText: '好的',\r\n          confirmColor: '#818FFB',\r\n          success: function (res) {\r\n\t\t\t  // 保存成功，隐藏画布\r\n            if (res.confirm) {\r\n              that.setData({\r\n                isShowPoster: false\r\n              })\r\n            }\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }"}
{"title": "微信小程序一键转快应用 ", "author": "Rolan", "pub_time": "2020-6-4 00:41", "content": "微信小程序与快应用兼容版的语法有 95% 以上的相似度，通过 npm 包，我们可以实现从微信小程序源码到快应用源码的一键转换。1. 安装 qa-adapterqa-adapter 可用于帮助已有微信小程序或者支付宝小程序的开发者，快速将项目适配到快应用兼容版中去。使用 npm 安装：npm install -g qa-adapter使用 yarn 安装：yarn add -g qa-adapter2. 使用使用adt命令转换项目adt [sourceDir] [destDir?optional]参数说明参数作用-v，--version输出工具版本号-l，--logs在转换后项目的根目录中输出转换记录文件logs.txt-d，--diff在转换后项目的 .quickapp 目录中生成转换前后代码的对比报告3. 案例对于我们已经上架了的微信小程序 性能排行榜 ：只需一条命令就能转换为快应用：adt ./miniprogram/rank ./quickapp/rank转换结果：可以看到转换过来的快应用的界面显示，数据请求等过程都是正确的。也可以对比转换前后的代码。adt -d ./miniprogram/rank ./quickapp/rank对于 95% 以上的小程序可以做到一键转换，对于中大型的小程序，本转换工具能减少 95% 的迁移工作量。转换过程中有任何问题欢迎及时反馈，开发快应用的过程中有任何问题也可与我一起交流。交流 QQ 群： 171685021"}
{"title": "微信小程序悬浮客服 ", "author": "Rolan", "pub_time": "2020-6-5 00:54", "content": "1.html:<movable-area class=\"movableArea\">    <movable-view class=\"movableView\" direction=\"all\" inertia x=\"{{x}}\" y=\"{{y}}\" bindchange=\"touchChange\" bindtouchend=\"touchEnd\">        <view class=\"dock-service-wrap {{pin?'active':''}} {{isTouch?'round':''}}\">            <view class=\"mi-flex mi-align-items-center\">                <mi-icon src=\"/images/kefu.png\" width=\"90rpx\" bindtap=\"handlePin\" />                <navigator wx:if=\"{{!user.id}}\" url=\"/pages/login/login\">                    <view class=\"dock-service-tips\">                        <text>HI\\n</text>                        <text>我是您的顾问，有任何问题\\n随时都可以联系我。</text>                    </view>                </navigator>                <button wx:else class=\"btn-contact\" session-from=\"sobot|{{user.nickname}}|{{user.avatar_url}}||transfer_action={{transferAction}}\" open-type=\"contact\">                    <view class=\"dock-service-tips\">                        <text>HI，{{user.nickname}}\\n</text>                        <text>我是您的顾问，有任何问题\\n随时都可以联系我。</text>                    </view>                </button>                <mi-icon class=\"dock-service-dock\" src=\"/images/icon_arrow_right@2x.png\" width=\"28rpx\" bindtap=\"handleDock\" />            </view>        </view>    </movable-view></movable-area>2.css:.movableArea {  position: fixed;  top: 0;  width: 100vw;  height: 100vh;  pointer-events: none;  z-index: 100;}.movableView {  pointer-events: auto;  width: 120rpx;  height: 120rpx;}.dock-service-wrap {  padding: 15rpx;  width: 132rpx;  max-height: 148rpx;  background-color: rgba(0, 0, 0, 0.7);  border-radius: 150rpx 0 0 150rpx;  overflow: hidden;  transition: border-radius 100ms ease-in-out;}.dock-service-wrap.active {  width: 480rpx;}.dock-service-wrap.round {  width: 120rpx;  border-radius: 150rpx}.dock-service-wrap.active .dock-service-tips {  display: block;}.dock-service-wrap.active .dock-service-dock {  display: block;}.dock-service-tips {  display: none;  margin-left: 16rpx;  color: #fff;  font-size: 24rpx;  line-height: 30rpx;  text-align: left;}.dock-service-dock {  margin-left: 16rpx;  display: none;}3.js:import {  getUser} from \"./../../core/user.js\";Component({  options: {    styleIsolation: \"apply-shared\"  },  /**   * 组件的属性列表   */  properties: {    y: {      type: Number,      value: 0,    },  },  /**   * 组件的初始数据   */  data: {    user: {},    transferAction: \"[{'actionType':'to_group','deciId':'b3d80dcbba164dffa8edf2a95feb9bf2','optionId':'4'}]\",    initX: wx.getSystemInfoSync().safeArea.width,    x: wx.getSystemInfoSync().safeArea.width,    pin: false,    isTouch: false,  },  lifetimes: {    attached: function () {      this.setData({        user: getUser(),      });    },    ready: function () {      this.createSelectorQuery().select(\".dock-service-wrap\").fields({        size: true      }, res => {        this.setData({          initX: wx.getSystemInfoSync().safeArea.width - res.width,          x: wx.getSystemInfoSync().safeArea.width - res.width        });      }).exec();    }  },  pageLifetimes: {    show: function () {      this.setData({        user: getUser(),      });      // console.log(this.data.user);    }  },  /**   * 组件的方法列表   */  methods: {    touchChange(event) {      let {        x,        y,        source      } = event.detail;      if (source === \"touch\") {        this.setData({          isTouch: true,          pin: false        });      } else if (x === this.data.initX) {        this.setData({          pin: false,          isTouch: false        });      }    },    touchEnd(event) {      // 只有拖动的时候才会去改变y坐标      // 其它因素触发该事件不会改变y坐标      if (this.data.isTouch === false) {        return;      }      let y = event.changedTouches[0].clientY;      this.setData({        x: this.data.initX,        y: y,      });    },    handlePin() {      // 如果拖动还未结束，点击无效      if (this.data.isTouch === true) {        return;      }      if (this.data.pin === false) {        this.setData({          pin: true,        });        this.createSelectorQuery().select(\".dock-service-wrap\").fields({          size: true        }, res => {          this.setData({            x: wx.getSystemInfoSync().safeArea.width - res.width          });        }).exec();      } else {        this.handleDock();      }    },    handleDock() {      this.setData({        x: this.data.initX,      });    }  }"}
{"title": "微信小程序分类导航图标左右滑动 ", "author": "Rolan", "pub_time": "2020-6-4 00:51", "content": "wxml<scroll-view scroll-y=\"true\" scroll-into-view=\"{{scrollIntoView}}\" bindscroll=\"onScroll\">\r\n    <swiper class=\"page_class\" indicator-dots=\"true\" autoplay=\"\" interval=\"\" duration=\"500\">\r\n        <block wx:if=\"{{homeDate.brand}}\">\r\n            <swiper-item>\r\n\r\n                <view class=\"page_li center\" wx:for=\"{{homeDate.brand}}\" catchtap='toList' data-cateid=\"{{item.id}}\" data-pid=\"-2\">\r\n                    <block wx:if=\"{{index<8}}\">\r\n                        <image src='{{item.logo}}' mode='aspectFill'></image>\r\n                        <text>{{item.name}}</text>\r\n                    </block>\r\n                </view>\r\n\r\n            </swiper-item>\r\n        </block>\r\n        <block wx:if=\"{{homeDate.brand.length>7}}\">\r\n            <swiper-item>\r\n                <view class=\"page_li page_num center\" wx:for=\"{{homeDate.brand}}\" catchtap='toList' data-cateid=\"{{item.id}}\" data-pid=\"-2\">\r\n                    <block wx:if=\"{{index>7}}\">\r\n                        <image src='{{item.logo}}' mode='aspectFill'></image>\r\n                        <text>{{item.name}}</text>\r\n                    </block>\r\n                </view>\r\n            </swiper-item>\r\n        </block>\r\n    </swiper>\r\n</scroll-view>wxss.page_class{padding:0 0 20rpx;margin-top: 20rpx;white-space: nowrap;height: 360rpx;}\r\n.page_class .page_li{width: 20%;margin-top: 20rpx;color: #3d3d3d;}\r\n.page_class image{width: 90rpx;height: 90rpx;border-radius: 50%;display: block;margin: 0 auto 8rpx;}\r\n.page_class .page_li {float: left;display: -webkit-flex;flex-direction: column;flex-wrap: wrap;width: 25%;text-align: center;margin: 10rpx 0;}\r\n.swiper-box .wx-swiper-dots.wx-swiper-dots-horizontal{margin-bottom: 2rpx;}\r\n.page_class .wx-swiper-dot{width:40rpx;display: inline-flex;height: 10rpx;justify-content:center;border-radius: 6rpx;margin: 0;}\r\n.page_class .wx-swiper-dot::before{content: '';flex-grow: 1;background: rgba(255,255,255,0.8);border-radius: 6rpx;}\r\n.page_class .wx-swiper-dot-active::before{background:#f6414a;}\r\n.page_num:nth-child(-n+8){display: none;}"}
{"title": "Python Flask微信小程序登录流程及登录api实现代码 ", "author": "Rolan", "pub_time": "2020-6-8 00:32", "content": "一、先来看看效果接口请求返回的数据：二、官方登录流程图三、小程序登录流程梳理：1、小程序端调用wx.login2、判断用户是否授权3、小程序端访问 wx.getUserInfo4、小程序端js代码：wx.login({\r\n success: resp => {\r\n // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n console.log(resp);\r\n var that = this;\r\n // 获取用户信息\r\n wx.getSetting({\r\n success: res => {\r\n if (res.authSetting['scope.userInfo']) {\r\n // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n wx.getUserInfo({\r\n success: userResult => {\r\n var platUserInfoMap = {}\r\n platUserInfoMap[\"encryptedData\"] = userResult.encryptedData;\r\n platUserInfoMap[\"iv\"] = userResult.iv;\r\n wx.request({\r\n\t\t\t url: 'http://127.0.0.1:5000/user/wxlogin',\r\n\t\t\t data: {\r\n\t\t\t platCode: resp.code,\r\n  platUserInfoMap: platUserInfoMap,\r\n\t\t\t },\r\n\t\t\t header: {\r\n\t\t\t \"Content-Type\": \"application/json\"\r\n\t\t\t },\r\n\t\t\t method: 'POST',\r\n\t\t\t dataType:'json',\r\n\t\t\t success: function (res) {\r\n\t\t\t console.log(res)\r\n  \twx.setStorageSync(\"userinfo\", res.userinfo) //设置本地缓存\r\n\t\t\t },\r\n\t\t\t fail: function (err) { },//请求失败\r\n\t\t\t complete: function () { }//请求完成后执行的函数\r\n\t\t\t })\r\n }\r\n })\r\n }\r\n }\r\n })\r\n }\r\n })5、后端服务器访问code2session，通过code2Session这个api接口来获取真正需要的微信用户的登录态 session_key 和 openid 和 unionid6、后端服务器校验用户信息，对 encryptedData 解密微信小程序登录后获得session_key后，返回了encryptedData，iv的数据，其中encryptedData解密后包含了用户的信息，解密后的json格式如下：{\r\n \"openId\": \"OPENID\",\r\n \"nickName\": \"NICKNAME\",\r\n \"gender\": GENDER,\r\n \"city\": \"CITY\",\r\n \"province\": \"PROVINCE\",\r\n \"country\": \"COUNTRY\",\r\n \"avatarUrl\": \"AVATARURL\",\r\n \"unionId\": \"UNIONID\",\r\n \"watermark\":\r\n {\r\n \"appid\":\"APPID\",\r\n \"timestamp\":TIMESTAMP\r\n }\r\n}7、新建解密文件——WXBizDataCrypt.pyfrom Crypto.Cipher import AES 这边一般会遇到 ModuleNotFoundError:No module named \"Crypto\" 错误（1）执行 pip3 install pycryptodome（2）如果还是提示没有该模块，那就虚拟环境目录 Lib—-site-package 中查看是否有 Crypto 文件夹，这时你应该看到有 crypto 文件夹，将其重命名为 Crypto 即可import base64\r\nimport json\r\nfrom Crypto.Cipher import AES\r\n\r\nclass WXBizDataCrypt:\r\n def __init__(self, appId, sessionKey):\r\n self.appId = appId\r\n self.sessionKey = sessionKey\r\n\r\n def decrypt(self, encryptedData, iv):\r\n # base64 decode\r\n sessionKey = base64.b64decode(self.sessionKey)\r\n encryptedData = base64.b64decode(encryptedData)\r\n iv = base64.b64decode(iv)\r\n\r\n cipher = AES.new(sessionKey, AES.MODE_CBC, iv)\r\n\r\n decrypted = json.loads(self._unpad(cipher.decrypt(encryptedData)))\r\n\r\n if decrypted['watermark']['appid'] != self.appId:\r\n raise Exception('Invalid Buffer')\r\n\r\n return decrypted\r\n\r\n def _unpad(self, s):\r\n return s[:-ord(s[len(s)-1:])]8、Flask的 /user/wxlogin api代码：import json,requests\r\nfrom WXBizDataCrypt import WXBizDataCrypt\r\nfrom flask import Flask\r\n\r\n@app.route('/user/wxlogin', methods=['GET','POST'])\r\ndef user_wxlogin():\r\n data = json.loads(request.get_data().decode('utf-8')) # 将前端Json数据转为字典\r\n appID = 'appID' # 开发者关于微信小程序的appID\r\n appSecret = 'appSecret' # 开发者关于微信小程序的appSecret\r\n code = data['platCode'] # 前端POST过来的微信临时登录凭证code\r\n encryptedData = data['platUserInfoMap']['encryptedData']\r\n iv = data['platUserInfoMap']['iv']\r\n req_params = {\r\n 'appid': appID,\r\n 'secret': appSecret,\r\n 'js_code': code,\r\n 'grant_type': 'authorization_code'\r\n }\r\n wx_login_api = 'https://api.weixin.qq.com/sns/jscode2session'\r\n response_data = requests.get(wx_login_api, params=req_params) # 向API发起GET请求\r\n resData = response_data.json()\r\n openid = resData ['openid'] # 得到用户关于当前小程序的OpenID\r\n session_key = resData ['session_key'] # 得到用户关于当前小程序的会话密钥session_key\r\n\r\n pc = WXBizDataCrypt(appID, session_key) #对用户信息进行解密\r\n userinfo = pc.decrypt(encryptedData, iv) #获得用户信息\r\n print(userinfo)\r\n '''\r\n 下面部分是通过判断数据库中用户是否存在来确定添加或返回自定义登录态（若用户不存在则添加；若用户存在，返回用户信息）\r\n\r\n --------略略略略略略略略略-------------\r\n\r\n 这部分我就省略啦，数据库中对用户进行操作\r\n '''\r\n\r\n return json.dumps\r\n({\r\n\"code\": 200, \"msg\": \"登录成功\",\"userinfo\":userinfo}, indent=4, sort_keys=True, default=str, ensure_ascii=False)总结到此这篇关于Python Flask微信小程序登录详解及登录api实现的文章就介绍到这了,更多相关Python Flask微信小程序登录详解及登录api实现内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！"}
{"title": "taro 实现购物车逻辑的实例代码 ", "author": "Rolan", "pub_time": "2020-6-8 00:31", "content": "效果taro是什么？Taro 是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/京东小程序、快应用、H5、React-Native 等）运行的代码。本代码是基于Taro UI 开发的，虽然是基于 taro框架开发的，但购物车的整体逻辑与微信小程序逻辑是基本一样的Taro UI是一款基于 Taro 框架开发的多端 UI 组件库需要安装taro ui$ npm install taro-ui\r\ntaro官方文档taroUI 官方文档cart/index.jsx页面代码\r\nimport Taro, { Component } from '@tarojs/taro'\r\nimport { View, Checkbox, CheckboxGroup } from '@tarojs/components'\r\n//用到了taro的三个组件\r\n//想了解可以去查看taro的官方文档\r\nimport './index.scss'\r\nimport { AtButton, AtInputNumber, AtCard } from 'taro-ui'\r\nimport { request, toast } from '../../utils/index'\r\n\r\nclass Index extends Component {\r\n constructor(props) {\r\n  super(props)\r\n  this.state = {\r\n   message: '', //购物车为空时显示的信息\r\n   cartdata: [], //购物车的数据列表\r\n   isactive: false, //全选按钮是否选中\r\n   check:false, //单个商品购物车是否被选中\r\n   totalnum:0, //总数量\r\n   totalprice:0, //总价格\r\n   activedata:[] //复选框选中的数据列表\r\n  }\r\n\r\n }\r\n componentDidShow () {\r\n  //获取购物车数据\r\n  try {\r\n   const token = Taro.getStorageSync('token') //这两个数据是我在登录页面，登录时添加到本地的token和用户id\r\n   const userid = Taro.getStorageSync('userid')\r\n   if (token) { //如果登录了\r\n    const usrename = Taro.getStorageSync('username') //同样登录时添加到本地的用户名\r\n    Taro.setNavigationBarTitle({ //改变导航栏的标题\r\n     title: usrename + '---购物车'\r\n    })\r\n    request({ //这里的request是封装后的方法\r\n     url: '/cart', //接口\r\n     data: { //需要传递的数据\r\n      token,\r\n      userid\r\n     }\r\n    }).then(res => {\r\n     console.log(res.data)\r\n     const { code } = res.data\r\n     if (code === '10119') { //后端返回的值 ，判断状态\r\n      toast({ title: '登录已经过期，请从新登录' })\r\n      Taro.navigateTo({  //跳转到登录页\r\n       url: '/pages/login/index'\r\n      })\r\n     } else if (code === '10012') {\r\n      this.setState({\r\n       message: '购物车空空如也'\r\n      })\r\n     } else {\r\n     //因为taro是基于react的，在react中，状态不能直接改变，要用this.setState\r\n      this.setState({ //登录成功，购物车有数据时，将购物车的列表数据添加到购物车数据中\r\n       cartdata: res.data.data\r\n      })\r\n     }\r\n    })\r\n   } else { //如果没登录\r\n    toast({ title: '请登录' })\r\n    Taro.navigateTo({ //跳转到登录页面\r\n     url: '/pages/login/index'\r\n    })\r\n   }\r\n\r\n  } catch (e) {\r\n\r\n  }\r\n }\r\n componentDidUpdate(){\r\n  //计算总数量，总价格\r\n  let num=0;\r\n  let price=0;\r\n  if(this.state.activedata.length!=0){ //如果选中的数组长度不为0时，就是有商品被选中了\r\n   this.state.activedata.map((item)=>{ //map遍历数组\r\n    num+= +item.num  //将数量相加 + 号为一元运算符，将字符串类型转换为数值类型\r\n    price+=item.num*item.price  //求价格\r\n   })\r\n   this.setState({ //设置值\r\n    totalnum:num,\r\n    totalprice:price\r\n   })\r\n  }else{ //如果没有商品被选中\r\n   this.setState({\r\n    totalnum:0,\r\n    totalprice:0\r\n   })\r\n  }\r\n\r\n }\r\n render() {\r\n  return ( //结构开始\r\n   <View>{\r\n    this.state.message.length === 0 ? null : //如果 message不为空的话，就代表着购物车没有数据，所以显示购物车空空如也，去选购，如果为空，代表着购物车有数据，不显示\r\n     <View onClick={() => { //点击事件 去主页选购商品\r\n      Taro.switchTab({\r\n       url: '/pages/home/index'\r\n      })\r\n     }}> {this.state.message}去选购</View>\r\n   }\r\n    <Checkbox checked={this.state.isactive} onClick={()=>{ //全选按钮 check代表着按钮是否选中 因为taro中的checkbox的onchange方法，不支持小程序，所以没办法，只能用 onClick方法\r\n     let active=!this.state.isactive   //实现点击选中状态取反\r\n     this.setState({\r\n      isactive:active\r\n     })\r\n     if(active===true){ //如果全选，就代表着 购物车的所有商品都被选中，所以，将购物车列表数据全给选中的数组，将单个商品的状态全部设为选中\r\n      this.setState({\r\n       check:true,\r\n       activedata:this.state.cartdata\r\n      })\r\n     }else{//否则，选中商品数组为空，将单个商品的状态全部设为未选中\r\n      this.setState({\r\n       check:false,\r\n       activedata:[]\r\n      })\r\n     }\r\n    }}>全选</Checkbox>\r\n\r\n    <CheckboxGroup  onChange={(evt)=>{ //复选框组，<CheckboxGroup/>中选中项发生改变是触发 change 事件，detail = value:[选中的 Checkbox 的 value 的数组]\r\n     const {detail:{value}}=evt\r\n     if(value.length===this.state.cartdata.length){ //选中的数组的长度如果等于购物车列表的长度是全选\r\n      this.setState({\r\n       isactive:true,  //全选按钮被选中\r\n       activedata:this.state.cartdata  //选中商品数组为购物车的列表数组\r\n      })\r\n     }else{ //否则未全选\r\n      var i;\r\n      var data=[];\r\n      for ( i in value){  //因为value数组里的值为选中的checkbox的value的值，我设置的为cartid\r\n       data.push(...(this.state.cartdata.filter(item=>{ //过滤下购物车的列表数据，将cartid相等的对象取出来，放进data数组中，...是展开运算符，加他是因为在控制台打印的时候发现，每个对象外面都加了一个【】，没办法，这里应该是有简单的写法的，但因为当时累了，也没有细想，就只能写成这样了，\r\n        return item.cartid==value[i]\r\n       })))\r\n      }\r\n      console.log(data,this.state.cartdata)\r\n      this.setState({\r\n       isactive:false,//全选按钮未被选中\r\n       activedata:data //设置选中商品的数组\r\n       //至此，计算总数量，总价格、全选、单选的逻辑就全完成了，至于为什么写成这样，是因为taro是基于react的标准的，没有计算属性，没有双向绑定\r\n      })\r\n     }\r\n    }}>\r\n     {\r\n      this.state.cartdata.map((item, index) => //循环显示购物车数据\r\n       <AtCard\r\n        title={item.proname}\r\n        thumb={item.proimg}\r\n        extra={'$'+item.price}\r\n        key={item.proid}\r\n\r\n       >\r\n        <View><Checkbox value={item.cartid} checked={this.state.check}></Checkbox>\r\n        {/* 每个商品前的复选框 */}\r\n         <AtInputNumber //数量加减\r\n          min={0}\r\n          max={10}\r\n          step={1}\r\n          value={item.num} //之间的值\r\n          onChange={this.change.bind(this, item,index)} //onchange输入框值改变时触发的事件，开发者需要通过 onChange 事件来更新 value 值变化，onChange 函数必填\r\n         />\r\n         <AtButton type='primary' size='small' onClick={this.del.bind(this,item)}>删除</AtButton>\r\n         {/* 删除按钮 */}\r\n        </View>\r\n\r\n       </AtCard>\r\n      )\r\n     }\r\n    </CheckboxGroup>\r\n    <View>总数量：{this.state.totalnum}</View>\r\n    <View>总价格：{this.state.totalprice}</View>\r\n   </View>\r\n  )\r\n }\r\n del(item){ //删除方法\r\n //item代表着商品的数据\r\n  try{\r\n   const token = Taro.getStorageSync('token')\r\n   if(token){ //如果有token值\r\n    request({ //数据请求   删除接口\r\n     url: '/cart/delete',\r\n     data: {\r\n      token,\r\n      cartid: item.cartid\r\n     }\r\n    }).then(res => {\r\n     const { code } = res.data\r\n     if (code === '10119') { //后端接口 返回值\r\n      toast({ title: '登录状态过期，请重新登录' })\r\n      Taro.navigateTo({  //跳转到登录页面\r\n       url: '/pages/login/index'\r\n      })\r\n     }else{\r\n       toast({title:'删除成功!'}) //显示提示框 封装的一个方法 其实到这步，商品就已经删除了，但页面还没有发生变化，所以我们要处理下页面\r\n       let id=item.cartid\r\n       let data1=this.state.cartdata.filter(item=>{ //过滤下不等于被删除的商品id，将未删除的商品，放到data1中\r\n        return item.cartid!=id\r\n       })\r\n       let data2=this.state.activedata.filter(item=>{ //在选中情况下\r\n        return item.cartid!=id\r\n       })\r\n       this.setState({ //设置下购物车列表数据\r\n        cartdata:data1,\r\n        activedata:data2\r\n       })\r\n     }\r\n    })\r\n   }else{ //如果没有token值\r\n    toast({ title: '请登录' })\r\n    Taro.navigateTo({ //跳转到登录页面\r\n     url: '/pages/login/index'\r\n    })\r\n   }\r\n  }catch(e){\r\n\r\n  }\r\n }\r\n change(item,index,evt) {\r\n  //数量改变\r\n  console.log(evt)\r\n  //item代表着商品的数据\r\n  //index，为当前改变的是那个商品的值，\r\n  //evt为改变后的数值\r\n  try {\r\n   const token = Taro.getStorageSync('token')\r\n   if (token) { //如果有token值\r\n    if (evt === '0') { //数量为0 我设置的为删除商品，与上面的删除一致，这里我就不再解释了\r\n     request({\r\n      url: '/cart/delete',\r\n      data: {\r\n       token,\r\n       cartid: item.cartid\r\n      }\r\n     }).then(res => {\r\n      const { code } = res.data\r\n      if (code === '10119') {\r\n       toast({ title: '登录状态过期，请重新登录' })\r\n       Taro.navigateTo({\r\n        url: '/pages/login/index'\r\n       })\r\n      }else{\r\n        toast({title:'删除成功!'})\r\n        let id=item.cartid\r\n        let data1=this.state.cartdata.filter(item=>{\r\n         return item.cartid!=id\r\n        })\r\n        let data2=this.state.activedata.filter(item=>{ //在选中情况下\r\n        return item.cartid!=id\r\n       })\r\n        this.setState({\r\n         cartdata:data1,\r\n         activedata:data2\r\n        })\r\n\r\n      }\r\n     })\r\n    }else{ //改变的值不为0 ，\r\n     request({\r\n      url: '/cart/update', //更新接口\r\n      data: {\r\n       token,\r\n       cartid: item.cartid,\r\n       num:evt  //将改变的值直接付给num\r\n      }\r\n     }).then(res => {\r\n      const { code } = res.data\r\n      if (code === '10119') {  //后端验证\r\n       toast({ title: '登录状态过期，请重新登录' })\r\n       Taro.navigateTo({ //跳转到登录页\r\n        url: '/pages/login/index'\r\n       })\r\n      }else{\r\n        toast({title:'更新成功!'})\r\n        item.num=evt //改变下数量\r\n       // var newitem=item\r\n       // var data=this.state.cartdata.map(item=>{\r\n       //  return item.cartid===newitem.cartid ?newitem :item\r\n       // })\r\n       var data=this.state.cartdata //将购物车里边数据赋给data ，因为在react中，状态不能直接改变\r\n       data[index]=item // 将新的对象赋给数组的第index对象\r\n       this.setState({ //设置下\r\n        cartdata:data\r\n       })\r\n      }\r\n     })\r\n    }\r\n   } else {//如果没有token值\r\n    toast({ title: '请登录' })\r\n    Taro.navigateTo({\r\n     url: '/pages/login/index'\r\n    })\r\n   }\r\n\r\n  } catch (e) {\r\n\r\n  }\r\n\r\n }\r\n}\r\n\r\nexport default Indexcart/index.scss页面代码\r\n@import \"~taro-ui/dist/style/components/card.scss\";\r\n@import \"~taro-ui/dist/style/components/button.scss\";\r\n@import \"~taro-ui/dist/style/components/loading.scss\";\r\n@import \"~taro-ui/dist/style/components/icon.scss\";\r\n@import \"~taro-ui/dist/style/components/input-number.scss\";utils/index.js代码\r\nconst publicurl =''，//接口就不放上去了，因为也不是我的，这里就放接口前的公共网址\r\nimport Taro from '@tarojs/taro'\r\nexport function request(options){\r\n const {url,data,method}=options\r\n wx.showLoading({ //显示loading框\r\n  title: '加载中',\r\n })\r\n return new Promise((resolve,reject)=>{\r\n  Taro.request({ //数据请求 与小程序类似\r\n   url: publicurl+url,\r\n   data:data || {},\r\n   method:method || 'GET',\r\n   success(res){\r\n    //成功\r\n    resolve(res)\r\n   },\r\n   fail(err){\r\n    //失败\r\n    reject(err)\r\n   },\r\n   complete(){\r\n    // complete 接口调用结束的回调函数\r\n    wx.hideLoading(); //隐藏loading框\r\n   }\r\n  })\r\n })\r\n}\r\n\r\nexport function toast(options){\r\n  const {title,icon, duration}=options\r\n  Taro.showToast({\r\n   title,\r\n   icon: icon || 'none',\r\n   duration:duration || 1000\r\n  })\r\n}总结到此这篇关于taro 实现购物车逻辑的实例代码的文章就介绍到这了,更多相关taro 购物车逻辑内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！"}
{"title": "记录一下微信小程序图片拖拽，放大，位移效果实现 ", "author": "Rolan", "pub_time": "2020-6-8 00:52", "content": "因为需求需要对图片进行操作，放大，位移，旋转等思路也是参考别的博客这个写的比较全https://blog.csdn.net/king096...我看的第一篇是这个https://www.jb51.net/article/...实现思路1 在一个区域里绘制图片，2 记录所有图片的坐标，旋转角度，尺寸，中心点，缩放比例3 创建cavnas画布，白底色，然后根据记录的图片的一些状态绘制4 根据canvas生产出图片先上效果蓝框为拖拽区域红框为cavnas绘制部分贴代码wxmlcanvas标签正常情况下应该是隐藏或者让他定位到十万八千里外因为需要展示效果，所以就没有隐藏，实际上线可以自己隐藏掉<view class=\"container\">\r\n  <button class=\"mini-btn\" bindtap=\"generate\" type=\"primary\" size=\"mini\">生成图片</button>\r\n<block wx:for=\"{{materialList}}\" wx:key=\"index\">\r\n  <image class=\"img-list\" bindtap=\"addImg\" data-index=\"{{index}}\" mode=\"aspectFit\"  src=\"{{item.image}}\"></image>\r\n</block>\r\n{{itemList.length}}\r\n  <view class=\"img-box\" id=\"img-box\">\r\n    <!-- *************操作区域************* -->\r\n    <block wx:for=\"{{itemList}}\" wx:key=\"index\">\r\n      <!-- 圆心坐标 <text style='position:absolute;top:{{item.y}}px;left:{{item.x}}px;width:2px;height:2px;background-color:yellow;z-index:500'></text> -->\r\n      <!-- {{item.scale}}---{{item.r}} -->\r\n      <view class='touchWrap' style='transform: scale({{item.scale}});top:{{item.top}}px;left:{{item.left}}px; '>\r\n        <view class='imgWrap {{item.active? \"touchActive\":\"\"}}' style=\"transform: rotate({{item.angle}}deg);\">\r\n          <view>\r\n            <image style=\"width:{{item.height}}px; height:{{item.width}}px\" class=\"item-img\" src='{{item.image}}' bindload='loadImg' data-index=\"{{index}}\" data-id='{{item.id}}' bindtouchstart='wraptouchStart' bindtouchmove='WraptouchMove'></image>\r\n          </view>\r\n          <!-- <image  src='{{item.image}}'   bindload='loadImg' bindtouchend='WraptouchEnd'></image> -->\r\n          <image class='x' hidden=\"{{!item.active}}\" bindtap=\"hiddenImg\" data-index=\"{{index}}\" src='../../assets/img/wqy-close.png' style='transform: scale({{item.oScale}});transform-origin:center;' data-id='{{item.id}}'></image>\r\n          <image class='o' hidden=\"{{!item.active}}\" data-index=\"{{index}}\" src='../../assets/img/wqy-stretch.png' style='transform: scale({{item.oScale}});transform-origin:center;' data-id='{{item.id}}' bindtouchstart='touchStart' bindtouchmove='touchMove'>\r\n          </image>\r\n        </view>\r\n      </view>\r\n    </block>\r\n  </view>\r\n  <canvas class='maskCanvas' canvas-id=\"maskCanvas\" style='width:{{canvasWidth}}px; height:{{canvasHeight}}px;'></canvas>\r\n</view>js部分/*\r\n * @Description: \r\n * @Author: 冷山冷杉 <wqy.mail@foxmail.com>\r\n * @Date: 2020-06-04 11:58:14\r\n * @LastEditTime: 2020-06-05 16:14:51\r\n * @LastEditors: 冷山冷杉  <wqy.mail@foxmail.com>\r\n * @FilePath: \\mini-fullalumni\\pages\\photoTest\\photoTest.js\r\n */\r\nconst app = getApp()\r\nconst maskCanvas = wx.createCanvasContext('maskCanvas', this)\r\nlet items = []\r\nPage({\r\n  data: {\r\n    itemList: [\r\n    ],\r\n    materialList: [\r\n      {\r\n        id: null,\r\n        image: 'https://img3.doubanio.com/view/subject/m/public/s9074663.jpg',//图片地址\r\n        top: 0,//初始图片的位置 \r\n        left: 0,\r\n        x: 0, //初始圆心位置，可再downImg之后又宽高和初始的图片位置得出\r\n        y: 0,\r\n        scale: 1,//缩放比例 1为不缩放\r\n        angle: 0,//旋转角度\r\n        active: true //判定点击状态\r\n      },\r\n      {\r\n        id: null,\r\n        image: 'https://img9.doubanio.com/view/subject/m/public/s3893375.jpg',\r\n        top: 0,\r\n        left: 0,\r\n        x: 0,\r\n        y: 0,\r\n        scale: 1,\r\n        angle: 0,\r\n        active: false\r\n      }\r\n    ],\r\n    canvasWidth: null,\r\n    canvasHeight: null\r\n  },\r\n  onReady() {\r\n    const query = wx.createSelectorQuery()\r\n    query.select('#img-box').boundingClientRect()\r\n    query.selectViewport().scrollOffset()\r\n    query.exec((res) => {\r\n      this.setData({\r\n        canvasWidth: res[0].width,\r\n        canvasHeight: res[0].height\r\n      })\r\n    })\r\n    // wx.getSystemInfo({ // 获取系统信息\r\n    //   success: sysData => {\r\n    //     this.sysData = sysData\r\n    //     // 设置画布宽高，this.sysData.windowWidth为屏幕的宽度\r\n    //     this.setData({\r\n    //       canvasWidth: this.sysData.windowWidth, // 如果觉得不清晰的话，可以把所有组件、宽高放大一倍\r\n    //       canvasHeight: this.sysData.windowWidth\r\n    //     })\r\n    //   }\r\n    // })\r\n  },\r\n  addImg(e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let materialList = this.data.materialList\r\n    let itemList = this.data.itemList\r\n    if (itemList.length) {\r\n      materialList[index].id = itemList[itemList.length - 1].id + 1\r\n    } else {\r\n      materialList[index].id = 1\r\n    }\r\n    itemList.push(JSON.parse(JSON.stringify(materialList[index])))\r\n    this.setData({ itemList })\r\n  },\r\n  loadImg(e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let itemList = this.data.itemList\r\n    // x,y为圆心的距离, +25: 按钮定位的距离 + 按钮自身大小/2\r\n    itemList[index].width = e.detail.width\r\n    itemList[index].height = e.detail.height\r\n    itemList[index].x = e.detail.width / 2 + 25\r\n    itemList[index].y = e.detail.height / 2 + 25\r\n    this.setData({ itemList })\r\n  },\r\n  hiddenImg(e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let itemList = this.data.itemList\r\n    itemList.splice(index, 1)\r\n    this.setData({ itemList })\r\n  },\r\n  wraptouchStart: function (e) {\r\n    let items = this.data.itemList;\r\n    for (let i = 0; i < items.length; i++) { //旋转数据找到点击的\r\n      items[i].active = false;\r\n      if (e.currentTarget.dataset.id == items[i].id) {\r\n        items[i].active = true; //开启点击属性\r\n        items[i].lx = e.touches[0].clientX; // 记录点击时的坐标值\r\n        items[i].ly = e.touches[0].clientY;\r\n      }\r\n    }\r\n    this.setData({  //赋值 \r\n      itemList: items\r\n    })\r\n  },\r\n  WraptouchMove: function (e) {\r\n\r\n    let index = e.currentTarget.dataset.index\r\n    let items = this.data.itemList;\r\n    //移动时的坐标值也写图片的属性里\r\n    items[index]._lx = e.touches[0].clientX;\r\n    items[index]._ly = e.touches[0].clientY;\r\n\r\n    //追加改动值\r\n    items[index].left += items[index]._lx - items[index].lx; // x方向\r\n    items[index].top += items[index]._ly - items[index].ly;  // y方向\r\n    items[index].x += items[index]._lx - items[index].lx;\r\n    items[index].y += items[index]._ly - items[index].ly;\r\n\r\n    //把新的值赋给老的值\r\n    items[index].lx = e.touches[0].clientX;\r\n    items[index].ly = e.touches[0].clientY;\r\n    this.setData({//赋值就移动了\r\n      itemList: items\r\n    })\r\n  },\r\n  // 触摸开始事件 items是this.data.itemList的全局变量，便于赋值 所有的值都应给到对应的对象里\r\n  touchStart: function (e) {\r\n\r\n    //找到点击的那个图片对象，并记录\r\n    let items = this.data.itemList;\r\n    let index = e.currentTarget.dataset.index\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n      items[i].active = false;\r\n      if (e.currentTarget.dataset.id == items[i].id) {\r\n        items[i].active = true;\r\n      }\r\n    }\r\n    //获取作为移动前角度的坐标\r\n    items[index].tx = e.touches[0].clientX;\r\n    items[index].ty = e.touches[0].clientY;\r\n    //移动前的角度\r\n    items[index].anglePre = this.countDeg(items[index].x, items[index].y, items[index].tx, items[index].ty)\r\n    //获取图片半径\r\n    items[index].r = this.getDistancs(items[index].x, items[index].y, items[index].left, items[index].top)\r\n  },\r\n  // 触摸移动事件 \r\n  touchMove: function (e) {\r\n    let items = this.data.itemList;\r\n\r\n    let index = e.currentTarget.dataset.index\r\n    // items[index].x = e.detail.width / 2\r\n    // items[index].y = e.detail.height / 2\r\n    // this.setData({itemList: items})\r\n    //记录移动后的位置\r\n    items[index]._tx = e.touches[0].clientX;\r\n    items[index]._ty = e.touches[0].clientY;\r\n    //移动的点到圆心的距离 * 因为圆心的坐标是相对与父元素定位的 ，所有要减去父元素的OffsetLeft和OffsetTop来计算移动的点到圆心的距离\r\n    items[index].disPtoO = this.getDistancs(items[index].x, items[index].y, items[index]._tx, items[index]._ty)\r\n    items[index].scale = items[index].disPtoO / items[index].r; //手指滑动的点到圆心的距离与半径的比值作为图片的放大比例\r\n    items[index].oScale = 1 / items[index].scale;//图片放大响应的右下角按钮同比缩小\r\n\r\n    //移动后位置的角度\r\n    items[index].angleNext = this.countDeg(items[index].x, items[index].y, items[index]._tx, items[index]._ty)\r\n    //角度差\r\n    items[index].new_rotate = items[index].angleNext - items[index].anglePre;\r\n\r\n    //叠加的角度差\r\n    items[index].angle += items[index].new_rotate;\r\n    //用过移动后的坐标赋值为移动前坐标\r\n    items[index].tx = e.touches[0].clientX;\r\n    items[index].ty = e.touches[0].clientY;\r\n    items[index].anglePre = this.countDeg(items[index].x, items[index].y, items[index].tx, items[index].ty)\r\n\r\n    //赋值setData渲染\r\n    this.setData({\r\n      itemList: items\r\n    })\r\n  },\r\n  /*\r\n *参数1和2为图片圆心坐标\r\n *参数3和4为手点击的坐标\r\n *返回值为手点击的坐标到圆心的角度\r\n */\r\n  countDeg: function (cx, cy, pointer_x, pointer_y) {\r\n    var ox = pointer_x - cx;\r\n    var oy = pointer_y - cy;\r\n    var to = Math.abs(ox / oy);\r\n    var angle = Math.atan(to) / (2 * Math.PI) * 360;//鼠标相对于旋转中心的角度\r\n    if (ox < 0 && oy < 0)//相对在左上角，第四象限，js中坐标系是从左上角开始的，这里的象限是正常坐标系 \r\n    {\r\n      angle = -angle;\r\n    } else if (ox <= 0 && oy >= 0)//左下角,3象限 \r\n    {\r\n      angle = -(180 - angle)\r\n    } else if (ox > 0 && oy < 0)//右上角，1象限 \r\n    {\r\n      angle = angle;\r\n    } else if (ox > 0 && oy > 0)//右下角，2象限 \r\n    {\r\n      angle = 180 - angle;\r\n    }\r\n\r\n    return angle;\r\n  },\r\n  getDistancs(cx, cy, pointer_x, pointer_y) {\r\n    var ox = pointer_x - cx;\r\n    var oy = pointer_y - cy;\r\n    return Math.sqrt(\r\n      ox * ox + oy * oy\r\n    );\r\n  },\r\n  generate: function () {\r\n    maskCanvas.save();\r\n    maskCanvas.beginPath();\r\n    //一张白图\r\n    maskCanvas.setFillStyle('#fff');\r\n    maskCanvas.fillRect(0, 0, this.data.windowWidth, this.data.canvasHeight)\r\n    maskCanvas.closePath();\r\n    maskCanvas.stroke();\r\n    this.data.itemList.forEach((val, index) => {\r\n      maskCanvas.save();\r\n      maskCanvas.translate(0, 0);\r\n      maskCanvas.beginPath();\r\n      maskCanvas.translate(val.x, val.y); // 圆心坐标\r\n      maskCanvas.rotate(val.angle * Math.PI / 180);\r\n      maskCanvas.translate(-(val.width * val.scale / 2) - 25, -(val.height * val.scale / 2) - 25)\r\n      maskCanvas.drawImage(val.image, 0, 0, val.width * val.scale, val.height * val.scale);\r\n      maskCanvas.restore();\r\n    })\r\n    maskCanvas.draw(false, (e) => {\r\n      wx.canvasToTempFilePath({\r\n        canvasId: 'maskCanvas',\r\n        success: res => {\r\n          this.setData({\r\n            canvasTemImg: res.tempFilePath\r\n          })\r\n          console.log(res.tempFilePath);\r\n\r\n        }\r\n      }, this)\r\n    })\r\n  }\r\n})csspage{\r\n  height:100%;\r\n}\r\n.img-list{\r\n  width: 100rpx;\r\n  height: 100rpx\r\n}\r\n.container{\r\n  height: 100%;\r\n}\r\n.img-box {\r\n  position: relative;\r\n  width: 80%;\r\n  overflow: hidden;\r\n  margin: auto;\r\n  border: 1px solid blue;\r\n  height: 60%;\r\n  \r\n}\r\n\r\n\r\n.maskCanvas {\r\n  /* display: none; */\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  border:1px solid red;\r\n}\r\n.o, .x {\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  position: absolute;\r\n}\r\n\r\n.o{\r\n  bottom: -20px;\r\n  right: -20px;\r\n}\r\n.x{\r\n  top: -20px;\r\n  left: -20px\r\n}\r\n.touchWrap {\r\n  position: absolute;\r\n}\r\n\r\n.imgWrap{\r\n  border: 1px solid transparent;\r\n\r\n}\r\n.touchActive{\r\n\r\n  border: 1px solid black;\r\n}jason{\r\n  \"navigationBarTitleText\": \"照片测试\",\r\n  \"usingComponents\": {},\r\n  \"disableScroll\": true\r\n}这是个demo，自己大概测过没问题因为页面简洁，如果要放在页面上换样式，可能会有问题仅供参考，仅供参考！"}
{"title": "原生小程序跨平台实现（微信/支付宝/百度）？ ", "author": "Rolan", "pub_time": "2020-3-23 00:31", "content": "前言\r\n微信推出小程序平台以来，国内各大公司陆续跟进，带来了小程序的繁荣。从开发者的视角，我们看到小程序开发者变多，各种小程序技术方案不断出现。\r\n\r\n\r\n小程序增强型开发框架的出现\r\n小程序原生框架能力扩充，典型的有 wepy/mpvue\r\n小程序跨端开发框架的出现\r\n * 通过编写一套代码，实现多个小程序平台运行，典型的有 taro/uniapp\r\n小程序与 web/native（app）融合的技术需求出现\r\n\t* 因 小程序/web/native 平台差异较大，虽然有许多框架进行了尝试，但还处于蛮荒时代，未出现得到一致认可的方案\r\n\r\n\r\n而这繁荣的背后也显得杂乱，影响开发者选择适合的技术方案。基于此，我们做了一次小程序跨平台开发方向的调研，并得出如下建议：\r\n\r\n原生小程序如何实现多平台投放？\r\n从我们的了解来看，目前小程序市场，大部分还是微信小程序应用，其次是支付宝小程序，百度小程序。对这几端的融合也是目前比较切合需求场景的需求。基于此，我们调研了从微信小程序到其它端的转换的情况，帮助大家了解如何快速实现微信小程序到其它小程序的迁徙。\r\n\r\n说明： 以下测试结果基于微信官方微信小程序 demo 调研而得\r\n\r\nAntmove 小程序转换器\r\n\r\n官网：ant-move.github.io/guide/\r\nGithub：github.com/ant-move/An…\r\n\r\nAntmove 是目前小程序转换开源解决方案里成熟度最高的，通过 Antmove 转换器，可以一键将微信小程序转换为其它平台小程序，也可以将支付宝小程序转换为其它平台小程序，目前还在持续维护更新。\r\n基于 Antmove 的多端开发相关介绍可以从这里了解\r\ntaro\r\n介绍：Taro 是一套遵循 React 语法规范的 多端开发 解决方案。\r\nGithub: github.com/NervJS/taro…\r\nTaro 本质上是一套自定义语法的跨端开发方案，但官方提供了微信小程序转换为 taro 代码的工具，基于此，用户可以借助于 taro 将微信小程序转换为 taro 代码，然后再将其转换为对应平台的小程序代码。\r\n不足\r\n\r\n\r\n需要进行两次转换才能可以得到对应平台的代码\r\n\r\n\r\n功能支持情况不是很理想，如下为将微信小程序官方 demo 转换为 taro，再转换其它平台的测试情况\r\n\r\n\r\n转支付宝：\r\n\r\n目前转码后点击事件失效，转码后框架上函数有报错，逻辑需要重新写\r\nsetData函数运行失败，项目没办法使用\r\n\r\n\r\n\r\n转百度小程序\r\n\r\n界面（不支持，需要修改的）\r\n\r\nflex相关样式设置失败\r\nbutton报错，getLaunchOptionsSync没有处理\r\nmap\r\n显示隐藏指南针\r\n开启俯视功能\r\n\r\n\r\n接口（不支持，需要修改的）\r\n\r\n登陆\r\n支付\r\n客服消息\r\n生物认证\r\n蓝牙\r\niBeacon\r\n搜索WIFI\r\n上传视频和图片\r\n动态加载字体\r\n储存数据报错\r\n多线程计算\r\n\r\n\r\n\r\n\r\n\r\n转头条小程序\r\n\r\n目前转码后点击事件失效，转码后框架上函数有报错，逻辑需要重新写\r\nsetData函数运行失败，项目没办法使用\r\n\r\n\r\n\r\n\r\n注： 目前转码工具初始化微信小程到taro代码会有图片路径处理错误，需要手动修改一下\r\n\r\n总结\r\n\r\n工具整体体验流畅，其设计核心是用react语法使用工具提供的API和组件完成项目开发，然后一键生成多端小程序\r\n目前对原生小程序（微信）转到taro的问题比较多，但是整体能够完成转码，只是转码后需要花费一定的精力重新处理各种问题\r\n\r\nuniapp\r\n介绍： uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台\r\nGithub： github.com/dcloudio/un…\r\n微信小程序转换 uniapp 代码指南\r\n总结\r\n\r\n需要手工将微信小程序改造成 uniapp 应用\r\n非官方版本有一个转换工具，但转换不理想，测试微信官方 demo 转换报错\r\n单纯开发多端小程序这个框架还是比较好用的，但是转码微信小程序没有一键转码功能，需要手动配置大量的文件，其开发成本比较高\r\n\r\nmpx\r\n介绍：相同风格的语言开发开发多端小程序的开发框架，语言风格类似小程序，支持双向数据绑定\r\nGithub：github.com/didi/mpx.gi…\r\n结论\r\n\r\n不同的小程序需要搭建不同的开发环境，并做好相应的配置，\r\n不支持原生小程序转换，但支持使用原生小程序组件/页面，对于完整的小程序转换成本较高\r\n\r\n\r\n说明：除了 Antmove 转换器外，其它方案解决方案的初衷是基于 react/vue 或自定义语法的角度来实现多端，所以微信小程序转换到多端这一转换流程并不包含来这些框架的所有能力和优势，对于原生小程序迁移到其它平台本文调研结果可以参考。\r\n\r\n非小程序语法多端方案对比\r\n\r\n这里主要指采用非小程序语法开发小程序应用。\r\n非小程序语法开发业务代码方案已有诸多的调研和说明，可参考如下链接：\r\n\r\n\r\n小程序开发：用原生还是选框架（wepy/mpvue/uni-app/taro）？\r\nChameleon\r\n深入测试一周，主流多端框架大比武~by DCloud\r\n\r\n关于小程序跨平台开发的看法\r\n存在的问题\r\n从上面我们可以看到随着小程序的繁荣，跨端融合这个概念被提得越来越多，也出现了许多解决该问题的框架。但这真的代表着跨端开发的繁荣吗？\r\n我觉得还不是，小程序和 web，小程序和 native app存在着天然的差异化，这是很难弥补的，虽然社区上有出现了很多的方案，但都还不能说成熟。\r\n只考虑小程序这一平台，差异性会小一点，但想做到完全的一套代码，多个小程序平台运行还是很难。这里有以下几个原因：\r\n\r\n各大厂商采用自己的小程序技术框架，难以进行标准化\r\n小程序会自带厂商基因，能力差异化\r\n\r\n虽然有如上的差异，但依然小程序间的跨平台还是看到了一定的可能性，这也是目前小程序跨端方案出现这么多的原因。\r\n展望未来\r\n虽然上面提及了跨平台开发的不足，但其优势依然存在，一套代码多处运行充满了诱惑。当我们将全端的要求降低，只考虑某些平台的情况下，已经出现了较为成熟的方案。\r\n\r\n大多数情况下其实我们需要的只是某一端或是几端的融合，在 taro 的统计示例中我们可以发现，微信小程序应用占比达 90%，即大多数的应用只用 taro 开发了微信小程序。uniapp 也提到绝大多数应用只用其来开发其中一端的应用。在 Antmove 的统计中，绝大部分的用户也只是微信小程序和支付宝小程序两端的融合要求。\r\n\r\n在小程序之前，多端融合就已经被提及推出，在前端领域中，react 在这方面做得比较成功。在 react 学习一遍，即可多处编写的理念下，较低成本的实现了多端的需求，如 react-web/react-native/react-sketch 等，也因此构建了丰富的 react 生态。\r\n除了 react 体系外，如下的方案则切实的实现了某些平台的跨端\r\n\r\nflutter - 高性能移动端跨平台框架\r\nelectron - PC 应用跨平台开发工具\r\nQT\r\n小程序\r\n\r\ntaro/uniapp/Antmove/rax/mpx/cml\r\n\r\n\r\n\r\n畅想未来，设备复杂化是个必然的趋势，而这也更考验着跨端技术方案是否足够成熟。"}
{"title": "小程序导航栏之导航面板 ", "author": "Rolan", "pub_time": "2020-4-2 00:55", "content": "导航面板\r\n导航系统起着组织内容和功能的作用，让它们按照产品的信息架构图进行连接，展现在在用户面前，导航将零散的内容和功能组织成了一个完成的有结构的系统，有时我们需要把更多的内容放置在导航栏的位置，因此需要一个导航面板\r\n导航面板是导航栏的一个扩展，从导航栏部分拖拽出导航面板，展示更多的入口\r\n\r\n\r\n\r\n\r\n支持自定义面板内容\r\n\r\n\r\n示例代码\r\nhttps://github.com/webkixi/aotoo-xquery  \r\n=> pages/navpad  \r\n复制代码\r\n配置说明\r\nconst Pager = require('../../components/aotoo/core/index')\r\nconst mkNavpad = require('../../components/modules/navpad')\r\nPager({\r\n  data: {\r\n    navPadConfig: mkNavpad({\r\n      id: '',\r\n      bindopen: null,\r\n      bindclose: null,\r\n      content: null,\r\n      navpadHeight: '90%', // 默认导航板高度\r\n      navpadTop: '85%', // 默认导航板初始位置\r\n      navpadOpen: '-80%' // 默认导航板打开高度\r\n    }),\r\n  }\r\n})\r\n复制代码id\r\n{Array} 配置实例的Id\r\nbindopen\r\n{Function} 弹开导航面板时的回调方法\r\nbindclose\r\n{Function} 关闭导航面板时的回调方法\r\ncontent\r\n{Array} 设置导航面板的内容\r\nnavpadHeight\r\n{String} 设置导航面板的高度，默认为全屏90%\r\nnavpadTop\r\n{String} 设置导航面板的默认位置, 默认为85%\r\nnavpadOpen\r\n{String} 设置导航面板打开时的占整屏高度, 默认为80%\r\n如何设置\r\n设置回调函数\r\nnavPadConfig: mkNavpad({\r\n  bindopen: function(){\r\n    // 导航栏面板弹开时响应\r\n  },\r\n  bindclose: function(){\r\n    // 导航栏面板关闭时响应\r\n  },\r\n  navpadHeight: '90%', // 默认导航板高度\r\n  navpadTop: '85%', // 默认导航板初始位置\r\n  navpadOpen: '-80%' // 默认导航板打开高度\r\n}),\r\n复制代码如何获得实例\r\nPager({\r\n  data: {\r\n    navPadConfig: mkNavpad({\r\n      id: 'idName',\r\n    }),\r\n  },\r\n  onReady(){\r\n    let that = this[idName]\r\n  }\r\n})  \r\n复制代码使用实例插入数据\r\nPager({\r\n  data: {\r\n    navPadConfig: mkNavpad({\r\n      id: 'idName',\r\n    }),\r\n  },\r\n  onReady(){\r\n    let that = this[idName]\r\n    // 插入一条数据\r\n    that.innerContent({ title: '好好学习，天天向上' })  \r\n\r\n    // 插入数组  \r\n    that.innerContent([\r\n      { title: '好好学习' },\r\n      { title: '天天向上' },\r\n    ])  \r\n    \r\n    // 追加数据  \r\n    that.appendContent([\r\n      { title: '好好学习' },\r\n      { title: '天天向上' },\r\n    ]) \r\n  }\r\n})\r\n复制代码设置文本内容\r\nmkNavpad({ content: [\r\n  '好好学习',\r\n  '天天向上'\r\n]})\r\n复制代码设置列表\r\nmkNavpad({ content: [\r\n  {title: '好好学习', itemClass: 'xuexi'},\r\n  {title: '天天向上', itemClass: 'xiangshang'},\r\n  {img: {src: 'path/to/img', itemClass: 'img-class'}},\r\n]})\r\n复制代码设置文档\r\nmkNavpad({ \r\n  content: [\r\n    {\"@md\": `markdown的文本内容`}\r\n  ]\r\n})\r\n复制代码设置复杂的图文\r\nmkNavpad({\r\n  content: [\r\n    {\r\n      img: {src: 'path/to/image'},\r\n      \"@md\": `文档描述内容`\r\n    },\r\n  ]\r\n})\r\n复制代码GITHUB源码\r\n查看演示"}
{"title": "vue和小程序项目中使用iconfont的方法 ", "author": "Rolan", "pub_time": "2020-5-20 00:45", "content": "一、vue中使用iconfont1、百度搜索iconfont或者阿里巴巴矢量图标库官网，注册登录；2、找到图标管理->新建项目，或者使用已有的项目，用于保存自己的图标；3、搜索自己需要的icon；4、添加到购物车中；5、购物车中就有了相应icon6、点击购物车，选择添加至项目。就是我们刚才创建的项目或者之前已有的项目7、点击确定，即可将icon添加到我们的项目中8、然后点击我的项目，找到自己的项目，即可看到刚才添加的icon9、点击下载至本地10、将下载的压缩包进行解压11、打开解压好的文件夹，找到iconfont.css12、把解压好的文件夹放入项目目录下，在vue项目中的index.html中引入即可使用如可以放在public文件夹下13、在组件中使用总结：三步搞定1、将iconfont下载至本地2、在项目中引入文件3、vue中直接使用，然后使用i标签，通过类来规定使用的icon4、小程序中把iconfont.css的后缀名改为wxss，在项目中直接使用i标签即可到此这篇关于vue和小程序项目中使用iconfont的方法的文章就介绍到这了,更多相关vue小程序使用iconfont内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！"}
{"title": "Golang：通过小程序获取微信 openid ", "author": "Rolan", "pub_time": "2020-3-24 00:13", "content": "为什么要获取小程序的 openid在开发微信小程序的过程中，小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。那么这个用户身份标识就是 openid。小程序获取 openid 的流程那么小程序获取 openid 的流程具体如下，这里我简化了一下，因为我们只需要获取到 openid 即可，具体可以参考 这里我们需要在小程序中调用 wx.login() 获取 code 码，然后将这个 code 码发送给后端，后端带着这个 code 码和 appid，appsecret 向微信接口发起 http 请求获取 openid。注意事项在开发的小程序中的 AppID 一定要和后端使用的 AppID 保持一致，否则会获取 openid 失败我们请求的微信 API 为 auth.code2Session ，请求地址为：GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code所需的四个参数为：属性类型默认值必填说明appidstring是小程序 appIdsecretstring是小程序 appSecretjs_codestring是登录时获取的 codegrant_typestring是授权类型，此处只需填写 authorization_codejs_code 就是我们通过 wx.login 得到的 code，grant_type 为 authorization_code，只剩下 appid 和 secret 需要我们登录 微信公总平台 里面找小程序代码演示为了方便操作，我们在 index 页面编写了一个 button，通过 button 触发事件<!--index.wxml-->\r\n<view class=\"container\">\r\n  <button bindtap=\"onGetOpenId\">点击获取openid</button>\r\n</view>然后编写事件函数：//index.js\r\nPage({\r\n  onGetOpenId() {\r\n    wx.login({\r\n      success: res => {\r\n        if (res.code) {\r\n          wx.request({\r\n            url: \"http://localhost:2020/openid\",\r\n            method: \"POST\",\r\n            data: {\r\n              code: res.code\r\n            },\r\n            success: res => {\r\n              console.log(res);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n});那么，在小程序中发送 http 请求强制要求地址必须为 https，由于我们在开发中，我们可以把强制 https 的设置关闭Go 语言后端代码演示小程序发过来的数据和去微信 API 获取的数据都是放在 http body 里，所以我们要从 body 获取package main\r\n\r\nimport (\r\n    \"encoding/json\"\r\n    \"fmt\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc main() {\r\n    http.HandleFunc(\"/openid\", getOpenID)\r\n    http.ListenAndServe(\":2020\", nil)\r\n}\r\n\r\nfunc getOpenID(writer http.ResponseWriter, request *http.Request) {\r\n    if request.Method != http.MethodPost {\r\n        return\r\n    }\r\n\r\n    var codeMap map[string]string\r\n    err := json.NewDecoder(request.Body).Decode(&codeMap)\r\n    if err != nil {\r\n        return\r\n    }\r\n    defer request.Body.Close()\r\n\r\n    code := codeMap[\"code\"]\r\n    openid, err := sendWxAuthAPI(code)\r\n    if err != nil {\r\n        return\r\n    }\r\n    fmt.Println(\"my openid\", openid)\r\n}\r\n\r\nconst (\r\n    code2sessionURL = \"https://api.weixin.qq.com/sns/jscode2session?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code\"\r\n    appID           = \"你的AppID\"\r\n    appSecret       = \"你的AppSecret\"\r\n)\r\n\r\nfunc sendWxAuthAPI(code string) (string, error) {\r\n    url := fmt.Sprintf(code2sessionURL, appID, appSecret, code)\r\n    resp, err := http.DefaultClient.Get(url)\r\n    if err != nil {\r\n        return \"\", err\r\n    }\r\n    var wxMap map[string]string\r\n    err = json.NewDecoder(resp.Body).Decode(&wxMap)\r\n    if err != nil {\r\n        return \"\", err\r\n    }\r\n    defer resp.Body.Close()\r\n\r\n    return wxMap[\"openid\"], nil\r\n}运行结果运行代码，在小程序中点击：结果："}
{"title": "通过微信小程序来实现 “钉钉打卡” ", "author": "Rolan", "pub_time": "2020-5-7 00:33", "content": "历史总结：\r\n\r\n微信小程序自定义组件 - 表格组件来啦\r\n记一次微信小程序项目分包，以及分包预下载\r\n微信小程序实战\r\n\r\n需求背景\r\n产品希望统计我们公司线下人员的考勤情况，钉钉的功能目前不能满足一天多次外勤打卡的需求，于是我们打算自己开发一套打卡系统。我们的线下工作人员日常使用的是我们内部的一个微信小程序，产品希望将外勤打卡的功能在小程序上实现。方便线下人员在同一个平台上操作。\r\n微信小程序外勤打卡\r\n我们线下工作人员遍布全国各地，每个人的工作地点可能各不一样，怎样让线下工作人员在指定的地方打卡呢？\r\n1.如何确定打卡的对象和范围\r\n为了方便统一打卡管理，添加一个模块给志愿者管理人员，由管理者添加外勤对象，线下工作者根据当前的定位，选择匹配到方圆1公里的外勤对象，选择对应要打卡的对象进行打卡。\r\n\r\n外勤对象: 线下工作者打卡的目标地\r\n\r\n2.如何保证一天多次打卡\r\n外勤打卡呢，一个线下工作一天要跑多个工作地点，每个地点都要进行打卡，如何保证一天多次打卡呢？产品希望他们每次出勤都有对应的签到和签退，没完成签退，不可以新建一次外勤，每次签到成功就创建了一次外勤，签退不限制地点，可以进行随时签退，这样就保证了每次出勤都是成对的。\r\n\r\n一次外勤：一对签到和签退，要先完成签退，才能到下个地点进行签退。\r\n\r\n3.打卡定位\r\n针对打卡功能，我们选用微信小程序开发里面的位置api：定位、和选点定位。\r\n\r\n\r\n位置api调用前需要 先 用户授权 scope.userLocation。\r\n\r\n这次主要使用的两个位置api:\r\n\r\nwx.chooseLocation 打开地图选择位置；\r\nwx.getLocation 获取当前的地理位置。\r\n\r\n\r\n对经纬度进行逆解析需要申请腾讯地图的 key，申请开发者密钥（Key）。\r\n\r\n来来来，签到了：\r\n\r\n4.如何防止通过刷接口打卡？\r\n\r\nMD5加密\r\n\r\n考虑到有可能通过抓包提交经纬度来进行打卡，我们前后端统一指定了一套打卡加密机制。我们采用的 MD5加密，对经纬度、时间戳、小程序密钥等组合加密，前端每次打卡，都要加密后32密钥传给后端，后端校验通过后，才可以打卡。这样就可以阻止部分通过接口打卡的骚操作了。\r\n\r\n打卡自拍\r\n\r\n我们要求每次签到签退都要进行自拍，虽然不能完全杜绝刷打卡，但却可以 避免一部分作弊。\r\n最终我们的打卡：\r\n小结\r\n最后对于开发团队的总结， 前端主动驱动，需求评估后，提前想好解决方案，尽量减少非预知问题，需求评估后可以提前做个demo，对技术选型、功能的实现程度，以及需求的开发周期的有个大致预期。\r\n参考\r\n\r\n微信小程序文档-位置api\r\n腾讯地图-申请key\r\n腾讯地图-微信小程序插件-地图选点插件"}
{"title": "旋转动画效果 ", "author": "Rolan", "pub_time": "2020-5-9 00:11", "content": "问题描述在小程序中，如果可以用一个动画效果展现一句话或一段文字，会比普通文字呈现更具吸引力，这不仅是体现更多样的文字效果，更是突出这段文字的一个方法。那么接下来就来看一下如何实现一个文字旋转的动画效果吧。效果图：解决方案1  wxml：这部分很容易实现，只需要设置一个点击旋转标签button以及对一条需要旋转的文字进行数据绑定即可。<view>   <view animation=\"{{animation}}\">我在做动画</view></view><button type=\"primary\"  bindtap=\"rotate\">旋转</button>2  js：js中需要先了解一个animation的api，其中的参数和方法如下：（1）duration: 动画持续多少毫秒。（2）timingFunction:“运动”的方式，本例中的“linear”代表动画以匀速的效果来呈现。（3）delay:多久后动画开始运行，也就是动画延迟开始的时间translate(100,-100)向X轴移动100的同时向Y轴移动-100。（4）step():一组动画完成，例如想让本例中的文字旋转，用this.animation.rotate(360).step()，其中360就表示旋转一周360°。代码如下：Page({   data: {     text: \"Page animation\",     animation: ''   },   onLoad: function (options) {   },   onReady: function () {     //实例化一个动画     this.animation = wx.createAnimation({       // 动画持续时间，单位ms，默认值 400       duration: 1500,       timingFunction: 'linear',       // 延迟多长时间开始       delay: 100,       transformOrigin: 'left top 0',       success: function (res) {         console.log(res)       }     })   },   //旋转   rotate: function () {     //顺时针旋转10度     this.animation.rotate(360).step()     this.setData({       //输出动画       animation: this.animation.export()     })  }})结语文字的动画效果远不止这一种，它可以实现很多样很丰富的形式，本篇只是一个基础的动画效果演示，后续将介绍更丰富的动画效果，欢迎持续关注。"}
{"title": "微信小程序性能优化实践 ", "author": "Rolan", "pub_time": "2020-5-7 00:21", "content": "本文主要是根据微信小程序官方优化建议和《2018微信公开课第七季上海站·小程序专场》的性能优化方案，针对性我们的小程序项目进行性能优化实践，将过程记录下来，方便以后查看，同时也希望能帮助到其他小伙伴，做好性能优化。毕竟一切性能优化都是为了更好的用户体验。小程序常见性能问题这个小程序为什么这么慢？这个小程序为什么滑不动了，卡住了？小程序在切页面的时候为什么会有延迟？为什么点击了没有反应，是不是挂掉啦？这些问题的场景都反映了小程序的性能问题，直接影响到用户体验。小程序如何进行性能优化？官方建议从这两方面进行优化：启动性能优化渲染性能优化启动性能优化小程序在整个启动流程中，一般需要完成几项工作：1.准备运行环境（微信自己处理的）2.下载，注入并执行对应小程序代码包3.渲染小程序首页开发者可以在第2，3去优化小程序的启动性能。1.代码包大小优化小程序在首次打开时，会去下载并执行代码包，随着代码包大小的上升，耗时也会相应增加。可以采取以下方案：分包使用分包对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务；而对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能。建议开发者按照功能的划分，拆分成几个分包，当需要用到某个功能时，才加载这个功能对应的分包。使用分包实践我们的一个小程序在两年多前开始开发的，在设计之初，我们没有考虑到这一点，当时也没有小程序分包的功能。好吧，我们还是迎来了这个问题。微信小程序在开发文档中明确指出，小程序的所有包大小必须限制在2M以内，超过大小，就算在开发者工具中都不能正常预览，更不能上传发版。解决问题的方法：将静态资源图片压缩，因为小程序的压缩算法对图片的压缩微乎其微，于是互，笔者对图片进行一轮压缩，并且将重复使用的图片，进行了公共提取，虽然官方推荐使用网络图片，但是还需要去维护静态资源，嫌麻烦，就放弃。将项目中的弃用的页面，以及不用的三方，进行了一波清除。很多项目现在都是通过webpack打包成不通的分包，资源懒加载的形式来优化，小程序也提供了这个功能：分包，笔者按照按照功能划分的原则，将同一个功能下的页面和逻辑放置于同一个目录下，成为一个分包。分包之后：注意：1. 自定义第三方组件，需要放在主包内，miniprogram_npm文件会直接打到主包里；2. 小程序的tab切换页，必须放在主包里。分包预下载分包预下载是为了解决首次进入分包页面时的延迟问题而设计的。如果能够在用户进入分包页面之前就预先将分包下载完毕，那么进入分包页面的延迟就能够尽可能降低。实践用户进行了某个操作，再去下载分包，延迟操作用户体验很差，于是乎笔者对上面的分包设置分包预下载。在 app.json 文件中配置：\"preloadRule\": {\r\n    \"pages/work/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\r\n        \"package-work\",\r\n        \"package-field-statistics\"\r\n      ]\r\n    },\r\n    \"pages/appeal/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\r\n        \"package-appeal\"\r\n      ]\r\n    }\r\n},\r\n复制代码这里建议不要一次性把所有分包预下载，这样的操作同样回带来性能问题。独立分包小程序中的某些场景（如广告页、活动页、支付页等），通常功能不是很复杂且相对独立，对启动性能有很高的要求。使用独立分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。建议开发者将部分对启动性能要求很高的页面放到特殊的独立分包中。实践项目中没有适合的场景，尚未实践。2.首屏渲染优化1. 提前首屏数据请求大部分小程序在渲染首页时，需要依赖服务端的接口数据，接口请求放到页面的生命周期 onLoad 中，而不是 onReady 里。 `：实践监听到页面加载，就校验登录情况，请求页面数据onLoad: function (options) {\r\n    app.checkAuth((error, token) => {\r\n      if (error) {\r\n        return\r\n      }\r\n      // 请求该页面的数据\r\n    })\r\n  },\r\n复制代码2. 缓存请求数据小程序提供了wx.setStorageSync等异步读写本地缓存的能力，数据存储在本地，返回的会比网络请求快。实践登录成功后将用户的token，以及用户信息都可以缓存到本地，记得退出登录的时候清楚缓存，:joy:。/**\r\n * 设置本地 token 缓存\r\n * @param {Object} session 服务器返回的数据\r\n * @param {String} session.access_token 存取token\r\n * @param {String} session.refresh_token 刷新token\r\n * @param {String} session.expires_in 有效期限，以秒为单位\r\n */\r\nexport function set(session) {\r\n  const localSession = Object.assign({}, session, {\r\n    expires_timestamp: getExpireTimestamp(session.expires_in)\r\n  });\r\n  wx.setStorageSync(SESSION_KEY, localSession);\r\n\r\n  _token = session.access_token;\r\n}\r\n\r\nexport function clear() {\r\n  wx.removeStorageSync(SESSION_KEY);\r\n  clearTimeout(refresh_timer);\r\n\r\n  _token = null;\r\n}\r\n复制代码3. 精简首屏数据推荐开发者延迟请求非关键渲染数据，缩短网络请求时延，与视图层渲染无关的数据尽量不要放在 data 中，以免传输垃圾数据，加快首屏渲染完成时间。实践通过id请求详情的情况，id在渲染层不需要，就可以不把id，定义在data中：// 原来代码\r\ndata: {\r\n    id: ‘’,\r\n    // ….\r\n},\r\nonLoad: function (options) {\r\n    \tthis.setData({\r\n\t\tid: options.id\r\n\t})\r\n\t// ….\r\n}\r\n\r\n// 改写后 不把id定义到data中\r\ndata: {\r\n    // ….\r\n},\r\napp.checkAuth((error, token) => {\r\n      const id = options.id === undefined ? '' : options.id;\r\n      this.id = id \r\n})\r\n复制代码接口返回的数据要做数据处理，不要直接都塞给data，减少冗余数据的双线程回传。也是 精简首屏数据优化的一部分。4. 避免阻塞渲染在小程序启动流程中，会顺序执行app.onLaunch, app.onShow, page.onLoad, page.onShow, page.onReady，所以，尽量避免在这些生命周期中使用Sync结尾的同步API，如 wx.setStorageSync，wx.getSystemInfoSync 等。实践项目中没有这样使用，有先见之明。:smile:渲染性能优化小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。** 常见的 setData 操作错误 **1. 频繁的去 setData导致了两个后果：Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；实践目前项目代码还是比较规范的，我们并没有把setData当成一个普通的对象去调用，晓得每次使用都需要两个线程间通信，WebView再去渲染的。哇，好棒。2. 每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程。实践目前每个接口的数据量并大，数据的量级还没达到影响脚步执行的程度，有需要的话再优化吧。3. 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。实践A页面上有个定时器，此时打开了B页面，A页面的定时器还在运行，继续抢占B页面的资源，B页面卡顿了，但是并不是B页面的造成的性能问题，这种问题就不太好排查。希望大家都能做个有始有终的人，定时器不用了要清除。下面demo，定时器在 onHide 时要清除掉。切记切记:point_down:/**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\nonShow: function () {\r\n    clearTimeout(getTodaytime)\r\n    this.updateNowTime()\r\n},\r\n\r\n/**\r\n   * 生命周期函数--监听页面隐藏\r\n */\r\nonHide: function () {\r\n    // 取消定时器 防止小程序内存不足，崩溃\r\n    clearTimeout(getTodaytime)\r\n},\r\nupdateNowTime() {\r\n    getTodaytime = setInterval(() => {\r\n      const myDate = new Date(); \r\n      const hours = myDate.getHours())\r\n      const minutes = myDate.getMinutes())\r\n      const seconds = myDate.getSeconds())\r\n\r\n      const newTime = hours + ':' + minutes + ':' + seconds;\r\n      this.setData({\r\n        newTime: newTime\r\n      })\r\n    }, 1000)\r\n  },\r\n复制代码2. 用户事件使用不当过多的使用bindTap、bindCatch不当的使用onPageScroll实践项目中展示没用使用该事件。3. 使用自定义组件在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性的影响。"}
{"title": "微信小程序 ｜ 开发常用事例 2 ", "author": "Rolan", "pub_time": "2020-5-9 00:42", "content": "前言\r\n小程序断断续续搞了有一段时间了，发现在某些情况下，第一次消耗 30 分钟，而后则几分钟即可。\r\n短暂微小积累，做一个积累，也希望帮助有需要的小伙伴～\r\n一起来看关于小程序常用事例\r\n话不多说，立刻开搞～\r\n一、 实现底部 Tab 栏\r\n\"tabBar\": {\r\n    \"color\": \"#515151\",\r\n    \"selectedColor\": \"#01509F\",\r\n    \"list\": [\r\n      {\r\n        \"pagePath\": \"pages/index/index\",\r\n        \"text\": \"预约\",\r\n        \"iconPath\": \"/images/tab_yuyue.png\",\r\n        \"selectedIconPath\": \"images/tab_yuyue_selected.png\"\r\n      },\r\n      {\r\n        \"pagePath\": \"pages/records/records\",\r\n        \"text\": \"记录\",\r\n        \"iconPath\": \"/images/tab_record.png\",\r\n        \"selectedIconPath\": \"/images/tab_record_selected.png\"\r\n      },\r\n      {\r\n        \"pagePath\": \"pages/mine/mine\",\r\n        \"text\": \"我的\",\r\n        \"iconPath\": \"/images/tab_mine.png\",\r\n        \"selectedIconPath\": \"/images/tab_mine_selected.png\"\r\n      }\r\n    ]\r\n  }\r\n复制代码二、 设置 Button 透明无边框\r\n.price_detail .img_info button::after {\r\n  border: none;\r\n}\r\n\r\n.price_detail .img_info button {\r\n  background: none;\r\n}\r\n复制代码三、 设置 CheckBox 样式为圆形 \r\n/* 重写 checkbox 样式 */\r\n\r\n/* 未选中的 背景样式 */\r\ncheckbox .wx-checkbox-input {\r\n  border-radius: 50%;\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n}\r\n\r\n/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */\r\ncheckbox .wx-checkbox-input .wx-checkbox-input-checked {\r\n  border: 1rpx solid #ff783b;\r\n  background: #ff783b;\r\n}\r\n\r\n/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */\r\ncheckbox .wx-checkbox-input .wx-checkbox-input-checked ::before {\r\n  border-radius: 50%;\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  line-height: 40rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  color: #fff;\r\n  /* 对勾颜色 白色 */\r\n  background: transparent;\r\n  transform: translate(-50%, -50%) scale(1);\r\n  -webkit-transform: translate(-50%, -50%) scale(1);\r\n}\r\n复制代码如下所示：\r\n\r\n四、 Text 文本内显示空格\r\n先来看下效果：\r\n\r\n使用全角空格即可，Mac 上使用方式如下：\r\n\r\nShift + option + B： 选择全角空格即可\r\n\r\n<van-field clearable label=\"微&emsp;&emsp;信\" placeholder=\"请输入微信号码\" />\r\n复制代码五、 点击左上角返回直接返回首页\r\n方式一：\r\n/**\r\n   * 生命周期函数--监听页面卸载\r\n   */\r\n  onUnload: function() {\r\n    wx.navigateBack({\r\n      delta: 6\r\n    })\r\n  },\r\n复制代码方式二：\r\n /**\r\n   * 返回首页\r\n   */\r\n   goBackHome: function() {\r\n    wx.switchTab({\r\n      url: '/pages/index/index',\r\n    })\r\n  },\r\n  \r\n /**\r\n  * 生命周期函数--监听页面卸载\r\n  */\r\n  onUnload: function() {\r\n    wx.switchTab({\r\n      url: '/pages/index/index',\r\n    })\r\n  },\r\n复制代码六、 跳转传值\r\n传值的话，一般可概括为如下俩种：\r\n\r\n下级页面需要得到上级页的 ID （传单值）；\r\n下级页面需要得到上级页例如订单信息以便与下级页填充 （传对象或者 Array 数组 等）。\r\n\r\n首先来看单值传值方式：\r\n<navigator url='/pages/order/order?type=4'>\r\n    <view>\r\n      <image src='../../images/ic_pay_error.png' />\r\n      <text>已退款</text>\r\n    </view>\r\n</navigator>\r\n复制代码接受值方式如下：\r\n/**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    console.log(\"Get Value:\" + options.type)\r\n  },\r\n复制代码而数组或者对象传值类似，区别在于传递对象 or 数组需要对传递的数据转换为字符串类型的 Json 串，如下：\r\nwx.navigateTo({\r\n      url: '/pages/xx/xx?activeTempList=' + JSON.stringify(this.data.activeTempList),\r\n    })\r\n复制代码而取值的地方则是需要将值再次转回去，这里需要注意传递值 key 是什么，获取的时候就 options. 什么：\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    this.setData({\r\n      orderInfo: JSON.parse(options.orderInfo),\r\n    })\r\n  },\r\n复制代码官方地址：developers.weixin.qq.com/miniprogram…\r\n七、 兼容 iPhone X\r\n附上一张未兼容和已兼容的效果图：\r\n\r\n适配步骤：\r\nStep 1： App.js 中检测当前设备是否为 iPhone X\r\n  globalData: {\r\n    // 是否为 iPhoneX 以上版本\r\n    isIphoneX: false\r\n  },\r\n  \r\n  /**\r\n   * 检测当前设备是否为 iPhone X 及以上\r\n   */\r\n  checkIsiPhoneX: function() {\r\n    const self = this\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        // 根据 model 进行判断\r\n        if (res.model.search('iPhone X') != -1) {\r\n          self.globalData.isIphoneX = true\r\n        }\r\n        // 或者根据 screenHeight 进行判断\r\n        // if (res.screenHeight == 812) {\r\n        //   self.globalData.isIphoneX = true\r\n        // }\r\n      }\r\n    })\r\n  },\r\n  \r\n  onLaunch: function() {\r\n    // 判断设备是否为 iPhone X 及以上\r\n    this.checkIsiPhoneX()\r\n  }\r\n复制代码Step 2： 设置兼容以及普通机型下的样式\r\n/* 提交按钮 */\r\n.submit_btn {\r\n  background: #d04801;\r\n  color: #fff;\r\n  border-radius: 50rpx;\r\n  margin: 30rpx;\r\n  font-size: 32rpx;\r\n  padding: 15rpx;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  position: absolute;\r\n}\r\n\r\n/* 点击效果 */\r\n.submit_btn:active {\r\n  opacity: 0.6;\r\n}\r\n\r\n/* 提交按钮 iPhone X */\r\n.submit_btn_iPhoneX {\r\n  margin-bottom: 68rpx;\r\n}\r\n复制代码Step 3： 具体的 Page.js 中匹配\r\nconst app = getApp()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    isIphoneX: app.globalData.isIphoneX,\r\n  },\r\n}\r\n复制代码Step 4： 未指定的控件设置对应的样式兼容\r\n<button class=\"{{ isIphoneX ? 'submit_btn submit_btn_iPhoneX' :'submit_btn'}}\" bindtap=\"{{phone.length ? 'confirmOrder' : ''}}\" open-type=\"{{phone.length ? '' : 'getPhoneNumber'}}\" bindgetphonenumber='bindgetphonenumber'>下一步</button>\r\n复制代码以上内容参考自如下链接：\r\n\r\nkangzubin.com/wxapp-iphon…\r\n\r\n八、来一个弹窗领优惠卷效果\r\n先来看一波效果：\r\n\r\n模拟器有毒，不要在意细节啦～\r\n分布拆解实现步骤：\r\n\r\n弹出层，采用 Vant Popup：youzan.github.io/vant-weapp/… ；\r\n一张红包背景图，扣的累死；\r\n一小撮洋码子。\r\n\r\n此处忽略集成 Vant 步骤。\r\n此处忽略集成 Vant 步骤。\r\n此处忽略集成 Vant 步骤。\r\nStep 1： 在所需要的页面的 json 文件中添加 popup 引用：\r\n  \"usingComponents\": {\r\n    \"van-popup\": \"/miniprogram_npm/vant-weapp/popup/index\"\r\n  }\r\n复制代码Step 2： 拼接红包效果\r\n首先附上样式内容：\r\n.van-popup {\r\n  background: transparent !important;\r\n}\r\n\r\n.red_packet_info {\r\n  position: absolute;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  width: 100%;\r\n}\r\n\r\n.red_packet_title {\r\n  font: 28rpx;\r\n  line-height: 72rpx;\r\n  color: #999;\r\n  margin-top: 16rpx;\r\n}\r\n\r\n.red_packet_price {\r\n  font-size: 72rpx;\r\n  line-height: 56rpx;\r\n  color: #666;\r\n  font-weight: bold;\r\n}\r\n\r\n.give_money_now {\r\n  border-radius: 50rpx;\r\n  margin: 0 100rpx;\r\n  position: relative;\r\n  color: rgb(0, 0, 0);\r\n  top: -200rpx;\r\n}\r\n复制代码随后附上实际码子：\r\n<van-popup show=\"{{ isShow }}\" bind:close=\"getHaveOffer\" close-on-click-overlay=\"true\" custom-class=\"van-popup\">\r\n  <div>\r\n    <div class=\"red_packet_info\">\r\n      <text class='red_packet_title'>优惠卷</text>\r\n      <text class='red_packet_price'>¥{{ offerPrice }}</text>\r\n    </div>\r\n    <image src='/images/bg_red_packet.png' style='height:800rpx;'></image>\r\n    <button class='give_money_now' bindtap='giveMoneyNow'>立即领取</button>\r\n  </div>\r\n</van-popup>\r\n复制代码Step 3： 事件搞起来\r\n  data: {\r\n    offerPrice: 100, // 优惠卷价格，为了演示，后续直接接口获取\r\n  },\r\n  。。。\r\n    /**\r\n   * 点击空白消失\r\n   */\r\n  getHaveOffer: function() {\r\n    console.log(\"---> getHaveOffer\")\r\n    this.setData({\r\n      isShow: false\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 点击获取优惠卷\r\n   */\r\n  giveMoneyNow: function() {\r\n    console.log(\"---> giveMoneyNow\")\r\n    this.setData({\r\n      isShow: false\r\n    })\r\n  },\r\n复制代码就这样，Bye～"}
{"title": "微信小程序 扩展组件 tabs 中的 swiper 部分高度自适应 ", "author": "Rolan", "pub_time": "2020-5-11 00:09", "content": "由于官方给了 swiper 固定高度150，且 swiper-item 都是 absolute 定位，所以实际应用中经常会碰到问题，在此记录一下修改方式。一、正常 npm 下载 tabs 包，并用开发者工具构建 npm二、修改构建出的目录 miniprogram_npm 目录下的 tabs 插件源码1、修改 tabs 插件的 wxml 文件，添加 style 属性，看下图位置2、修改 tabs 插件的 js 文件，添加 swiperStyle 属性3、使用 tabs 插件的页面添加 swiperStyle 属性，并动态计算高度赋值<mp-tabs \r\n  tabs=\"{{tabs}}\" \r\n  activeTab=\"{{activeTab}}\" \r\n  swiperClass=\"weui-tabs-swiper\"\r\n  bindtabclick=\"onTabCLick\"\r\n  bindchange=\"onChange\"\r\n  activeClass=\"tab-bar-title__selected\"\r\n  swiperStyle=\"height: {{tabSwiperHeight}}px\"\r\n>\r\n  <block wx:for=\"{{tabs}}\" wx:for-item=\"tab\" wx:for-index=\"index\" wx:key=\"index\">\r\n    <view class=\"tab-content tab-content-{{index}}\" slot=\"tab-content-{{index}}\" >\r\n        {{tab.title}}\r\n    </view>\r\n  </block>\r\n</mp-tabs>Page({\r\n  data: {\r\n    tabs: [{title: '首页'}, {title: '外卖'}, {title: '商超生鲜'}, {title: '购物'}, {title: '美食饮品'}, {title: '生活服务'}, {title: '休闲娱乐'}],\r\n    activeTab: 0,\r\n    tabSwiperHeight: 0\r\n  },\r\n  tabsSwiperHeight() {\r\n    // tab 组件内的swiper高度自适应问题\r\n    let index = this.data.activeTab;\r\n    let queryDom = wx.createSelectorQuery()\r\n    queryDom.select('.tab-content-' + index).boundingClientRect().exec(rect => {\r\n      this.setData({\r\n        tabSwiperHeight: rect[0].height\r\n      })\r\n    })\r\n  },\r\n  onTabCLick(e) {\r\n    const index = e.detail.index\r\n    this.setData({activeTab: index})\r\n  },\r\n  onChange(e) {\r\n    const index = e.detail.index\r\n    this.setData({activeTab: index})\r\n    this.tabsSwiperHeight();\r\n  }\r\n}"}
{"title": "从小程序不支持DOM操作开始深入分析小程序运行机制 ", "author": "Rolan", "pub_time": "2020-5-11 00:20", "content": "小程序现在如日中天，各大公司都推出了自己的小程序平台，目前看来运行机制都差不多，数据形成视图，渲染和逻辑分成两个线程，交互通过线程通信实现。刚开始接触小程序开发的时候，看到小程序的语法觉得很奇怪。看着像react和vue的结合体，疑惑为什么要这么费力的实现这么一套机制。难道是为了体现技术nb？ 用了一会就发现问题了，照搬pc开发的那套思想，特么小程序里不支持dom相关的api，很不方便。翻了很多遍微信和支付宝小程序的官方文档，终于有了一点理解。本文大部分是官方文档引用加上自己一点总结。web开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应。开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。 而在小程序中，二者是分开的，分别运行在不同的线程中，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。由于支付宝官方文档说明过于简略，本文结合了微信和支付宝小程序的特点总结，结合如有差异，欢迎指正。这部分在 微信 和支付宝小程序官方文档都有说明浏览器环境中渲染线程和js线程是互斥的由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。小程序页面文件结构小程序分为 app 和 page 两层。app 用来描述整个应用，page 用来描述各个页面。app 由三个文件组成，必须放在项目的根目录。文件必需作用app.js是小程序逻辑app.json是小程序全局设置app.acss否小程序全局样式表page 由四个文件组成，分别是：文件必需作用app.js是页面逻辑app.axml是页面结构app.json否页面配置app.acss否页面样式为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。单逻辑线程与多webview渲染线程小程序的逻辑层和渲染层是分开的两个线程,小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS脚本工作在逻辑层。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。从逻辑组成来说，一个小程序是由多个“页面”组成的“程序”。宿主环境提供了 App() 构造器用来注册一个程序App，需要留意的是App() 构造器必须写在项目根目录的app.js里，App实例是单例对象，在其他JS脚本中可以使用宿主环境提供的 getApp() 来获取程序实例。小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。const app = getApp(); \r\n复制代码参考资料: 微信1 、 微信2 、 微信3小程序的运行环境js运行引擎小程序的 JavaScript 代码分为逻辑层脚本和 sjs/wxs 脚本支付宝文档 说sjs和逻辑层运行在相同的 JavaScript 引擎的不同线程中。微信文档 又表示wxs是运行在webview中的，并且提供了更为强大的功能：如果在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍，在 android 设备上二者运行效率无差异；减少通信的次数，让事件在视图层（Webview）响应；用来响应小程序事件，目前只能响应内置组件的事件，不支持自定义组件事件；还能调用逻辑层的事件；对两者sjs/wxs差别表示吃瓜状态，支付宝的sjs明显功能弱了很多，毕竟鸡肋，一般用来模拟vue里的compued功能使用，无法作为事件回调。微信的wxs提供了更强大的支持。试了下sjs不带类似computed缓存功能两个平台都会对新预发的代码进行 babel 转换，使 JavaScript 引擎支持绝大多数 ES6 的新特性，但是对于内置对象未提供完全的Polyfill，具体支持情况可以查阅 支付宝 、 微信。在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中；在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中；视图层渲染在 iOS 上，视图层是由 WKWebView 来渲染的在 Android 上，微信是由自研 XWeb 引擎基于 Mobile Chrome 内核来渲染的，支付宝未找到说明，猜测是UC小程序渲染native组件原理小程序中，有一些组件其实是调用原生组件的，如map、video等，这些复杂交互的控件，原生能带来更好的性能与原生体验。简单说就是在期望插入原生控件的位置渲染一个HTML元素，拿到此DOM的位置，客户端在相同的位置上，根据宽高插入一块原生区域，位置或宽高发生变化时，组件会通知客户端做相应的调整。 可以直接看 官方文档为什么这么设计微信小程序的官方介绍 很全面了回到标题的问题。因为逻辑层Service中的代码与WebView中的代码完全隔离，JavaScriptCore中并没有document，window等对象（ECMAScript标准没有规定DOM，这其实是浏览器提供的）。js和视图（dom所在）没有运行在同一容器中。小程序开发可做的优化减少包的大小很好理解，小程序初次启动时，客户端需要从 CDN 下载小程序资源包，此后，如果小程序代码包未更新且还被保留在缓存中，则下载小程序代码包的步骤会被跳过。可以做的：减少在代码包中直接嵌入的资源文件，建议从 CDN 渠道上传清理无用代码和结构提升首屏，可以使用分包减少setData次数，合并setData每一次setData都是线程通信this.setData({ a: 1 })\r\nthis.setData({ b: 2 })\r\n//可优化为\r\nthis.setData({ a: 1, b: 2 })\r\n复制代码支付宝小程序提供了$batchedUpdatesthis.$batchedUpdates(() => {\r\n    this.setData({\r\n      counter: this.data.counter + 1,\r\n    });\r\n    this.setData({\r\n      counter: this.data.counter + 1,\r\n    });\r\n  });\r\n复制代码优化setDatasetData是线程通信传递数据，传输时数据需要序列化，框架提供了指定路径设置数据的方便，避免一次传输完整数据。this.setData({\r\n  'array[0]': 1,\r\n  'obj.x':2,\r\n});\r\n复制代码针对长列表， 支付宝小程序 提供了优化方法$spliceData，使用方式对应js数组的splicethis.$spliceData({ 'a.b': [1, 0, 5, 6] })\r\n复制代码针对长列表做优化，避免每次传递整个列表，只会从对应组件节点开始做差异比较使用 wxs /sjs小程序中事件响应也需要通过线程通信，如果频繁的触发可能会造成卡顿。例如页面有 2 个元素 A 和 B，用户在 A 上做 touchmove 手势，要求 B 也跟随移动。一次 touchmove 事件的响应过程为：a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B 的位置微信小程序里可以使用wxs响应事件优化，wxs是运行在webview中的，不需要跨线程通信。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 足够了：const wxsFunction = function(event, ownerInstance) {\r\n    const instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例\r\n    instance.setStyle({\r\n        \"font-size\": \"14px\" // 支持rpx\r\n    })\r\n    instance.getDataset()\r\n    instance.setClass(className)\r\n    // ...\r\n    return false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault\r\n}\r\n复制代码一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。 官方性能优化文档： 微信 、 支付宝 ;"}
{"title": "智能小程序--四种方式快速实现上拉触底加载更多效果 ", "author": "Rolan", "pub_time": "2020-5-11 00:12", "content": "在智能小程序的开发过程中，上拉加载是一种十分常见的加载效果，最近也收到了一些开发者在开发上拉加载时遇到的问题，今天的内容就为您介绍一下如果想实现下述效果的上拉加载，我们需要如何去做。以下是为大家总结的四种常见的实现方式：使用 onReachBottom 实现使用 scroll-view 组件实现使用信息流模板实现上拉加载使用 swiper 组件配合 onReachBottom 实现上拉加载使用 onReachBottom 实现智能小程序提供了 onReachBottom ，即页面上拉触底事件的处理函数。可以拿在 Page 中定义 onReachBottom 处理函数，监听该页面用户上拉触底事件，从而实现上拉加载。为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/7e944c0c3785bbdf4437c672dd0dc8e41584413934361工具下载链接： Windows / mac代码解析swan 文件是每个智能小程序页面的展现模板，类似于 Web 开发中的 HTML，所以我们先在 swan 文件中设置商品的展现样式：<view class=\"goodsList\">\r\n    <block s-for=\"item,index in goods\">\r\n        <view class=\"goodsItem\">\r\n            <view class=\"goodsImage\">\r\n                <image src=\"{{item.img}}\"></image>\r\n            </view>\r\n            <view class=\"goodsTitle\">\r\n                <text>{{item.title}}</text>\r\n            </view>\r\n        </view>\r\n    </block>\r\n</view>\r\n<view class=\"loading\">努力加载中...</view>在 js 文件中使用 onReachBottom 事件，当页面滑动到页面底部时，请求下一页展示数据，即实现上拉加载的效果。...\r\n...\r\nonReachBottom() {\r\n    //触底时继续请求下一页展示的数据\r\n    this.initData();\r\n}更多内容参见 onReachBottom使用 scroll-view 组件实现利用 scroll-view 组件实现上拉加载也是一种十分常见的方法，实现步骤与使用 onReachBottom 事件类似。scroll-view 是百度智能小程序提供的组件，可实现试图区域的横向滚动和竖向滚动。使用它的 bindscrolltolower 属性，当页面滚动到底部或右边的时候，则会触发scrolltolower事件，从而实现上拉加载的效果。为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/fccd71b098a7d3921b9958ccd9dba1071584414516291代码解析在 swan 文件中使用 scroll-view 组件，设置商品的展现样式。当页面滑动至底部时，触发 scrolltolower 事件，实现试图区域的竖向滚动。<view class=\"intro\">\r\n    <scroll-view\r\n     class=\"scrollview\"\r\n     scroll-y\r\n     bindscrolltolower=\"scrolltolower\"\r\n    >\r\n        <view class=\"goodsList\">\r\n            <view s-for=\"item,index in goods\">\r\n                <view class=\"goodsItem\">\r\n                    <view class=\"goodsImage\">\r\n                        <image src=\"{{item.img}}\"></image>\r\n                    </view>\r\n                    <view class=\"goodsTitle\">\r\n                        <text>{{item.title}}</text>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"loading\">努力加载中...</view>\r\n    </scroll-view>\r\n</view>使用信息流模板实现上拉加载信息流模版 是百度智能小程序提供的组件，可配置上拉刷新、列表加载、上拉加载功能，适用于列表信息展示，并可放置在页面的任何部分。与其它组件功能不同，使用信息流模板时需执行下述命令行，引入页面模板。npm i @smt-ui-template/page-feed并在进入page-feed文件夹后，执行下述命令行安装所有模板依赖。npm i为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/71af2b7f470b29b13f792c417fc5f03c1588757790402代码解析在 swan 文件中使用信息流模板，通过 smt-spin 组件加载更多数据。<smt-feed\r\n        class=\"smt-feed pull-down-refresh\"\r\n        pull-to-refresh\r\n        bind:scrolltolower=\"scrollToLower\"\r\n        text=\"{{text}}\"\r\n        style=\"height: 100vh\" <!-- 信息流组件作为局部滚动组件，必须在它的父级或本身指定高度 -->\r\n    >\r\n        <view class=\"goodsList\">\r\n            <view s-for=\"item,index in goods\">\r\n                <view class=\"goodsItem\">\r\n                    <view class=\"goodsImage\">\r\n                        <image src=\"{{item.img}}\"></image>\r\n                    </view>\r\n                    <view class=\"goodsTitle\">\r\n                        <text>{{item.title}}</text>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <smt-spin status=\"{{status}}\" bind:tap=\"reload\"></smt-spin>\r\n</smt-feed>在js文件中，利用在smt-spin组件上绑定的事件，实现加载更多的数据。...\r\n    ...\r\n    async scrollToLower() {\r\n        const goods = await this.initData();\r\n        await syncSetData(this, {\r\n            goods: goods.concat(this.data.goods || [])\r\n        });\r\n    },\r\n    ...\r\n    ...使用 swiper 组件配合 onReachBottom 实现上拉加载使用 swiper 组件配合 onReachBottom 的实现方法也比较常见，相较上边两种实现方式有些复杂，但同时也可以实现更加复杂的上拉加载场景。swiper 组件是智能小程序提供的滑块视图组件，与 swiper-item 组件配合使用，可实现 swiper 组件内 swiper-item 的滑动。需要动态设置 swiper 组件的高度，来保证每次滑动到底时都能触发 onReachBottom 。为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/20e8fd8c561418df7c4f24a850bf43461585224391100代码解析根据实际场景需要在 swan 文件中设置 tab，当设置多个tab时，实现效果如下：<view class=\"swiper-tab\">\r\n       <view class=\"tab-item {{currentTab==0 ? 'on' : ''}}\" data-current=\"0\" bindtap=\"swiperNav\">Tab1</view> \r\n       <view class=\"tab-item {{currentTab==1 ? 'on' : ''}}\" data-current=\"1\" bindtap=\"swiperNav\">Tab2</view>\r\n   </view>在 swan 文件中使用 swiper、swiper-item 组件。<swiper class=\"swiper\" style=\"height: {{swiperH}}\" current=\"{{currentTab}}\" bindchange=\"swiperChange\">\r\n        <swiper-item class=\"item\">\r\n            <view class=\"goodsList\">\r\n                <view s-for=\"item,index in goods\">\r\n                    <view class=\"goodsItem\">\r\n                        <view class=\"goodsImage\">\r\n                            <image bindload=\"imageLoad\" src=\"{{item.img}}\"></image>\r\n                        </view>\r\n                        <view class=\"goodsTitle\">\r\n                            <text>{{item.title}}</text>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n            <view class=\"loading\">努力加载中...</view>\r\n        </swiper-item>\r\n        <swiper-item class=\"item\">\r\n            <view class=\"goodsList\">\r\n                <view s-for=\"item,index in goods\">\r\n                    <view class=\"goodsItem\">\r\n                        <view class=\"goodsImage\">\r\n                            <image src=\"{{item.img}}\"></image>\r\n                        </view>\r\n                        <view class=\"goodsTitle\">\r\n                            <text>{{item.title}}</text>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n            <view class=\"loading\">努力加载中...</view>\r\n        </swiper-item>\r\n</swiper>在 js 文件中设置 swiper 组件的高度。// 给image添加load事件，保证图片全部加载出来再计算swiper-item的高度并赋值给swiper\r\nimageLoad() {\r\n       \r\n       let len = this.data.goods.length;\r\n        this.setData({\r\n            imgLoadNum: ++ this.data.imgLoadNum\r\n        })\r\n        if(this.data.imgLoadNum === len){\r\n            this.queryNodeInfo();\r\n        }\r\n    },\r\n    // 设置swiper的高度，如果不动态设置swiper的高度，当页面滑动到底部时，不会触发onReachBottom\r\n    queryNodeInfo: function(){\r\n        let currentTab = this.data.currentTab;\r\n        swan.createSelectorQuery().selectAll('.item').boundingClientRect((rect) => {  \r\n            this.setData({\r\n                swiperH: rect[currentTab].height + 'px'\r\n            })\r\n        }).exec();\r\n}在 js 文件中使用 onReachBottom 事件，当页面滑动到页面底部时，请求下一页展示数据，即实现上拉加载的效果。onReachBottom() { \r\n            this.initData();\r\n    },总结使用方法 1、2、3 可快速实现简单页面的上拉加载；而使用方法 4 可实现页面中存在多个 tab 的场景，比如：最新、最热列表的切换。开发者可根据实际情况选择不同的实现方法。最后，感谢各位开发者积极投身百度小程序的开发当中，在开发过程中有任何问题都可以在社区与官方或其他开发者进行互动，也可将您的意见发送邮件至smartprogramtech@baidu.com，期待您的参与！"}
{"title": "Node.js+Express+Mysql+Vue+ElementUI 实现登录注册列表 增删改查 全栈开发一个自己的 ... ", "author": "Rolan", "pub_time": "2020-5-11 00:52", "content": "前言记得雷布斯曾经说过：“我们要做米粉心中最牛逼的科技公司“。说实话，小米对我的影响很大（虽然我是个假米粉，但不是为了给小米打广告），小米这几年做出了很多用心的作品，使得大众能买到更高性价比的科技产品。虽然小米跟我没什么直接关系，但是他们的精神，是积极的的、充满力量的，是鼓舞并深深影响着我的，因为我也想做一个很牛逼的产品，我会因此感到自豪。有个灵魂拷问：程序员35岁能干嘛？前江后浪推前浪，我们如果没有爬上去管理层，那就会变成 又贵又没用的东西， 也就是职场中的奢侈品 ， 35岁之后，要明白我们终将被时代抛弃。 35岁以上的职场，只有两种人，职场中的奢侈品，和吃草的万里马。 把体力存进去，换成经验，换成智慧，换成钱的同同时，你要有一个梦想，你能喜欢并且35岁后可以赖此为生。我想要做的产品，是希望能帮助自己更好的规划人生，甚至希望能够造福所有迷茫中的人。所以自己琢磨着尝试开发一个全栈产品，可是，光靠激情没用，我只是一个前端，不是后台，不会写接口，也不会操作服务器，更不要说部署上线了。。。想想实在是太多不会的了。不巧的是，遇上疫情，这更让我想迫切实现我的产品梦。人还是要有梦想的，当你有了这个梦想，自然会有一股非三分钟热度的冲劲，万事都是开头难，管他呢，试了再说。于是，我的个人产品开始了。产品简介我的梦想，想做一个很牛逼的产品： 微信小程序《有梦必达》。有梦必达初衷是一个帮助迷茫的、还没有梦想的、还在寻找梦想的、有梦想却还不知道怎么实现的童鞋更好的寻找或实现梦想的微信小程序。有梦必达的初始设计功能有：登录、注册、找回密码、梦想列表、梦想详情、推荐课程、收藏、浏览记录、阅读数。产品不够完善，仍需要完善，不喜勿喷。开发流程备注：如果有同学完全按照此博客开发产品，可能会遇到坑，例如版本问题导致一些未知bug或者安装系统限制等等。在我开发过程中就遇到过很多小问题，不过只要坚持解决问题，这些问题都难不倒我。即使一开始遇到未知bug还是有点慌，但是后面通过各种方法寻找答案，解决完毕时会很自豪。总体开发流程如下：1、有一颗完成梦想的决心2、购买阿里云域名并且备案3、购买阿里云服务器Cent Os4、服务器安装Node、Npm、Cnpm、Mysql、Nginx并配置、PM25、本地安装Navicat Premium，连接远程服务器的Mysql、创建数据表、安装Xshell连接远程服务器、Xftp查看服务器文件6、Node+Express创建功能接口7、Vue+Element创建后台管理系统8、部署后台管理系统至域名服务器下9、微信小程序+Vant前端展示10、发布微信小程序一、有一颗完成梦想的决心如果想做一个产品，就应该把他当做一个梦想来看待，因为有了梦想，就会有冲劲，自己会觉得有意义，从而时刻保持冲劲，有热情去完成他，而不是三天打鱼两天晒网，顶多坚持几天就半途而废，到最后，产品没完成，自己也觉得自己能力有问题。所以，即使梦想再难，我们也要完成他，即使会慢一点！二、购买阿里云域名并且备案此处较为简单，直接去阿里云官网-购买域名即可 阿里云万网链接地址备注：购买域名后，需要做域名备案才能在线上访问（咱们要做就做正规的） 阿里云首次备案参考链接地址亦可参考其他博客方法备案，能实现备案目的就行三、购买阿里云服务器Cent Os四、服务器安装Node、Npm、Cnpm、Mysql、Nginx并配置、PM2五、本地安装Navicat Premium，连接远程服务器的Mysql、创建数据表、安装Xshell连接远程服务器、Xftp查看服务器文件由于三、四、五步骤篇幅过长， 直接移驾到开源中国预览六、Node+Express创建功能接口nodejs部分:1、package.json{\r\n  \"name\": \"nodeDream\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"app.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"parchments\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"body-parser\": \"^1.19.0\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"express\": \"^4.17.1\",\r\n    \"jsonwebtoken\": \"^8.5.1\",\r\n    \"multer\": \"^1.4.2\",\r\n    \"mysql\": \"^2.17.1\",\r\n    \"nodemon\": \"^2.0.2\",\r\n    \"request\": \"^2.88.2\"\r\n  }\r\n}\r\n复制代码2、connect.jsconst path = require(\"path\");\r\nconst mysql = require(\"mysql\");\r\nconst express = require(\"express\");\r\nconst app = express();//实例化一个app\r\nconst router = express.Router();\r\nconst cors = require('cors');\r\nconst jwt = require('jsonwebtoken');  //用来生成token\r\nconst request = require('request');\r\nconst bodyParser = require('body-parser');\r\napp.use(bodyParser.json());//post请求req.body为空的处理 json请求\r\napp.use(bodyParser.urlencoded({extended: false}));// 表单请求\r\n\r\n// 全局配置跨域\r\napp.use(cors());\r\n\r\n//本地访问不了已上传的图片，需要开启静态资源路径访问\r\nconst pathname = __dirname;\r\n//静态文件访问\r\napp.use(express.static(pathname));\r\n// 使用静态文件   这样可以获取静态文件的东西\r\napp.use(express.static('vueDream/dist'))\r\n\r\n\r\n//校验token\r\nfunction verifyToken(req, res, next){\r\n\tlet secretOrPrivateKey = 'jwtDream';//密钥\r\n\tjwt.verify(req.headers.token, secretOrPrivateKey, function (__err, decode) {\r\n\t\t//时间失效的时候/ 伪造的token\r\n\t\tif (__err) {\r\n\t\t\treturn res.status(401).send({\r\n\t\t\t\tcode: 401,\r\n\t\t\t\tdata: null,\r\n\t\t\t\tmessage: \"登录过期,请重新登录\"\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tnext();\r\n\t\t}\r\n\t})\r\n}\r\n//这里处理全局拦截，一定要写在最上面\r\napp.all('*', (req, res, next) => {\r\n\t//设置响应头\r\n    res.header(\"Access-Control-Allow-Origin\", \"*\"); //*表示允许的域名地址，本地则为'http://localhost'\r\n    res.header(\"Access-Control-Allow-Headers\", \"*\");\r\n    res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\r\n    res.header(\"Content-Type\", \"application/json;charset=utf-8\");\r\n\t\r\n\t//如果是登录 注册 找回密码  需要放行  无需校验token\r\n\tlet isLogin = req.url.indexOf('login');\r\n\tlet isRegister = req.url.indexOf('register');\r\n\tlet isForgotPassword = req.url.indexOf('forgotPassword');\r\n\tlet isCollection = req.url.indexOf('collection');\r\n\tlet isHistory = req.url.indexOf('history');\r\n\t// let isWechatLogin = req.url.indexOf('wechatLogin');\r\n\t// let isGetWxAccessToken = req.url.indexOf('getWxAccessToken');\r\n\t//微信小程序  并且是收藏接口需要校验token\r\n\tlet systype = req.headers.systype;\r\n\tif(systype === 'wechat'){\r\n\t\tif(isCollection !== -1 || isHistory !== -1){\r\n\t\t\tverifyToken(req, res, next)\r\n\t\t} else {\r\n\t\t\tnext();\r\n\t\t}\r\n\t} else if(systype === 'pc'){\r\n\t\t//pc   登录注册找回密码放行\r\n\t\tif(isLogin !== -1 || isRegister !== -1 || isForgotPassword !== -1){\r\n\t\t\tnext();\r\n\t\t}else{\r\n\t\t\tverifyToken(req, res, next)\r\n\t\t}\r\n\t}\r\n})\r\n\r\n//这一步目的是，当访问根路径时，把前端代码读取出来并显示\r\napp.get('/', (req, res) => {\r\n\t//服务器地址vueDream/dist/index.html\r\n    res.sendFile(path.resolve(__dirname, 'vueDream', 'dist', 'index.html'));\r\n})\r\n\r\n//配置mysql\r\nconst option = {\r\n\thost: \"www.yousit\",\r\n\t// host: \"49.985.02.01\",\r\n\tuser: 'admin',\r\n\tport: '3306', \r\n    password: \"mmmmmmmm.\",\r\n    database: \"node\",\r\n    connectTimeout: 5000, //连接超时\r\n    //multipleStatements: false //是否允许一个query中包含多条sql语句\r\n}\r\n\r\nlet pool;\r\nrepool();\r\nfunction Res ({ code = 200, message = '', data = {} }) {\r\n    this.code = code;\r\n    this.message = message;\r\n    this.data = data;\r\n}\r\nfunction resJson (_res, result) {\r\n    return _res.json(new Res(result))\r\n}\r\n\r\n//断线重连机制\r\nfunction repool() {\r\n    //创建连接池\r\n    pool = mysql.createPool({\r\n        ...option,\r\n        waitForConnections: true, //当无连接池可用时，等待（true）还是抛错（false）\r\n        connectionLimit: 200, //连接数限制\r\n        queueLimit: 0 //最大连接等待数（0为不限制）\r\n    })\r\n    pool.on('error', err => {\r\n        err.code === 'PROTOCOL_CONNECTION_LOST' && setTimeout(repool, 2000)\r\n    })\r\n    app.all('*', (_,__, next) => {\r\n        pool.getConnection( err => {\r\n            err && setTimeout(repool, 2000) || next()\r\n        })\r\n    })\r\n}\r\n\r\nmodule.exports = { app, pool, router, resJson , jwt , request}复制代码3、app.jsconst { app, pool } = require('./connect');\r\n\r\n//test\r\napp.all('/api', (req, res) => {\r\n    pool.getConnection((err, conn) => {\r\n        res.json({ type: 'test success'})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n})\r\n\r\n//引入上传路由\r\nconst multerUpload = require('./routes/upload');\r\nconst user = require('./routes/user');\r\nconst dreamList = require('./routes/dream');\r\nconst collectionList = require('./routes/collection');\r\nconst historyList = require('./routes/history');\r\n//使用路由\r\napp.use('/upload', multerUpload);\r\napp.use('/user', user);\r\napp.use('/dream', dreamList);\r\napp.use('/collection', collectionList);\r\napp.use('/history', historyList);\r\n\r\n//查看链接成功\r\napp.get('/api/test', function (req, res) {\r\n    res.json({ message: \"连接成功\" })\r\n});\r\n\r\n//开启监听\r\napp.listen(8888, () => {\r\n\tconsole.log(\"服务器端口8888开启中...\");\r\n})复制代码express接口部分:1、其中列表增删改查接口//梦想接口\r\nconst {app, pool, router, resJson, jwt } = require('../connect');\r\n\r\n// 查询\r\n/* \r\n  按分页显示账号列表的路由 /getData\r\n*/\r\napp.post(\"/api/dream/getData\", (req, res) => {\r\n\t\t//后期需要补充校验\r\n\t\tconsole.log(\"前端传过来的\",req.body)\r\n\t\t// 接收前端参数\r\n\t\tlet { pageSize, pageNo , name , userId} = req.body;\r\n\t\t// 默认值\r\n\t\tpageSize = pageSize ? pageSize : 5;\r\n\t\tpageNo = pageNo ? pageNo : 1;\r\n\t\tname = name ? name : null;\r\n\t\t   \r\n\t\t// 构造sql语句 （查询所有数据 按照时间排序）\r\n\t\tlet sqlStr = `select * from dream`;\r\n\t\t// 执行sql语句\r\n\t\tpool.getConnection((err, conn) => {\r\n\t\t\tconn.query(sqlStr, (err, data) => {\r\n\t\t\t  if (err) throw err;\r\n\t\t\t  // 计算数据总条数\r\n\t\t\t  let total = data.length;\r\n\t\t   \r\n\t\t\t  // 分页条件 (跳过多少条)\r\n\t\t\t  let n = (pageNo - 1) * pageSize;\r\n\t\t\t  //   sqlStr += ` limit ${n}, ${pageSize}`;//表示从pageNo条数据取，取pageSize条数据  此处空格不能去掉不然无响应\r\n\t\t\t  // 拼接分页的sql语句\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tsqlStr += ` where name like '%${name}%'`;\r\n\t\t\t\t\t// 执行sql语句 （查询对应页码的数据）\r\n\t\t\t\t\tconn.query(sqlStr, (_err, _data) => {\r\n\t\t\t\t\t  if (_err) throw _err;\r\n\t\t\t\t\t  res.send({\r\n\t\t\t\t\t\t  code: 1,\r\n\t\t\t\t\t\t  data: {\r\n\t\t\t\t\t\t\t  rows: _data,\r\n\t\t\t\t\t\t\t  total: _data.length,\r\n\t\t\t\t\t\t\t  pageNo: pageNo,\r\n\t\t\t\t\t\t\t  pageSize: pageSize,\r\n\t\t\t\t\t\t  },\r\n\t\t\t\t\t\t  message: '查询成功！'\r\n\t\t\t\t\t  });\r\n\t\t\t\t\t});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tsqlStr += ` limit ${n} , ${pageSize}`;\r\n\t\t\t\t\tconn.query(sqlStr, (_err, data) => {\r\n\t\t\t\t\t  if (_err) throw _err;\r\n\t\t\t\t\t  res.send({\r\n\t\t\t\t\t\t  code: 1,\r\n\t\t\t\t\t\t  data: {\r\n\t\t\t\t\t\t\t  rows: data,\r\n\t\t\t\t\t\t\t  total: total,\r\n\t\t\t\t\t\t\t  pageNo: pageNo,\r\n\t\t\t\t\t\t\t  pageSize: pageSize,\r\n\t\t\t\t\t\t  },\r\n\t\t\t\t\t\t  message: '查询成功！'\r\n\t\t\t\t\t  });\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tpool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n\t\t})\r\n  });\r\n\r\n//添加接口\r\napp.post('/api/dream/add', (req, res) => {\r\n    //后期需要补充校验\r\n    const data = req.body;\r\n    const name = req.body.name;\r\n    const sqlSameName = `select name from dream where name='${name}'`;\r\n    //先查询数据库 dream 表里是否有前端传来的name值了 如果有返回重复提示 否则插入数据库\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query(sqlSameName, data, (_err, _results) => {\r\n\t\t\tif(_err){console.log(_err); return false;}\r\n\t\t\t//根据查询表结果个数判断，如果1为数据库已经存在此名称，不可插入   0代表数据库不存在此名称，可插入\r\n\t\t\tif(_results.length > 0){\r\n\t\t\t\treturn res.json({\r\n\t\t\t\t\tcode: 0, \r\n\t\t\t\t\tmessage: \"不可重复添加！\", \r\n\t\t\t\t\tdata: null\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tconst sqlStr = 'insert into dream set ?';\r\n\t\t\t\tconn.query(sqlStr, data, (err, results) => {\r\n\t\t\t\t\tconsole.log(data)\r\n\t\t\t\t\tif (err) throw err;\r\n\t\t\t\t\tres.json({\r\n\t\t\t\t\t\tcode: 1,\r\n\t\t\t\t\t\tmessage: '添加成功',\r\n\t\t\t\t\t\tdata: results\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n});\r\n\r\n//修改\r\napp.post('/api/dream/edit', function (req, res) {\r\n    //后期需要补充校验\r\n    const data = req.body;\r\n    const id = req.body.id;\r\n    // let { name, collectionStatus, price, age, experience, education, analysis, introduce, duty, ask, coverImagePath, planImagePathArray, viedoUrl}  = req.body;\r\n    let { name, coverImagePath, content, viedoUrl , recommend}  = req.body;\r\n    let modSql = `update dream set \r\n\t\t\t\t\tname='${name}', \r\n\t\t\t\t\tcoverImagePath='${coverImagePath}', \r\n\t\t\t\t\tcontent='${content}', \r\n\t\t\t\t\tviedoUrl='${viedoUrl}',\r\n\t\t\t\t\trecommend='${recommend}'\r\n\t\t\t\t\twhere id ='${id}'`;\r\n\tlet nameSql = `select * from dream where name='${name}' and id !='${id}'`;\r\n\t//先查询数据库 dream 表里是否有前端传来的name值了 如果有返回重复提示 否则更新数据库\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query(nameSql, data, (err, results) => {\r\n\t\t\tconsole.log(results)\r\n\t\t\tif(results.length >= 1){\r\n\t\t\t\treturn res.json({\r\n\t\t\t\t\tcode: 0, \r\n\t\t\t\t\tmessage: \"名称已经存在！\", \r\n\t\t\t\t\tdata: null\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tconn.query(modSql, data, (err, results) => {\r\n\t\t\t\t\tres.json({\r\n\t\t\t\t\t\tcode: 1,\r\n\t\t\t\t\t\tmessage: '修改成功',\r\n\t\t\t\t\t\tdata: results\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n});\r\n//查看\r\napp.post('/api/dream/show', function (req, res) {\r\n    //后期需要补充校验\r\n    let data = req.body;\r\n\t//id是商品id\r\n    let { id , userId}  = req.body;\r\n    let modSql = `select * from dream where id='${id}'`;\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query(modSql, data, (err, results) => {\r\n\t\t\tif (err) {\r\n\t\t\t\tconsole.log(\"查询失败原因\",err)\r\n\t\t\t\treturn res.json({\r\n\t\t\t\t\tcode: 0, \r\n\t\t\t\t\tmessage: \"查询失败\", \r\n\t\t\t\t\taffectedRows: err\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// 1.查询出当前readCount\r\n\t\t\tresults[0].readCount = results[0].readCount+1;\r\n\t\t\tlet newReadCount = results[0].readCount;\r\n\t\t\t\r\n\t\t\t// 2.更新列表的id readCount\r\n\t\t\tlet sqlDreamCountStr = `update dream set readCount='${newReadCount}' where id ='${id}'`;\r\n\t\t\tconn.query(sqlDreamCountStr, data, (_err, _data) => {\r\n\t\t\t  if (_err) throw _err;\r\n\t\t\t  console.log('更新列表的id readCount成功');\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// 返回\r\n\t\t\tres.json({\r\n\t\t\t\tcode: 1,\r\n\t\t\t\tmessage: '查询成功',\r\n\t\t\t\tdata: results\r\n\t\t\t});\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n});\r\n\r\n//  删除\r\napp.post('/api/dream/del', (req, res) => {\r\n    //后期需要补充校验\r\n    console.log(req.body)\r\n    // let sqlStr = `DELETE FROM dream WHERE id = ${req.body.id}`;//单个删除\r\n    let sqlStr = `DELETE FROM dream WHERE id in (${req.body})`;\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query( sqlStr, (err , results) => {\r\n\t\t\tif(err) {\r\n\t\t\t\tconsole.log(err);\r\n\t\t\t}else {\r\n\t\t\t\tres.json({\r\n\t\t\t\t\tcode: 1,\r\n\t\t\t\t\tmessage: '删除成功',\r\n\t\t\t\t\tdata: results\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n})\r\n\r\nmodule.exports = router;复制代码2、更多功能接口 请前往github预览七、Vue+Element创建后台管理系统以vue-admin-template作为基础后台框架， 查看vue-admin-template地址 ，搭建我的小程序后台管理系统，为实现登录、注册、用户列表增删改查、梦想列表增删改查、梦想详情、收藏、收藏列表增删改查、浏览记录等功能八、部署后台管理系统至域名服务器下由于三、四、五步骤篇幅过长， 直接移驾到开源中国预览九、成果展示"}
{"title": "小程序 Button图标样式 实现悬浮按钮效果 ", "author": "Rolan", "pub_time": "2020-5-12 00:31", "content": "buttonbutton是小程序中重要的组件微信官方api但是这样的效果都不具备很好的美观性类似于Android开发中的悬浮按钮表单中的使用非表单中实现悬浮按钮效果将一个 矢量图图标 用小程序控件封装即可这里使用text控件 将矢量图作为其 background-Image代码wxml <text class=\"icon\"></text>wxss                这里使用的是 position fixed 所以可以实现   位置固定   类似悬浮按钮.icon {    bottom: 88rpx;  right: 50rpx;  position: fixed;  width: 100rpx;  height: 100rpx;  background-color: white;  border-radius: 50%;  background-size: 72% 72%;  background-position: center;  background-repeat: no-repeat;  background-image: url(\"data:image/svg+xml,%3Csvg t='1587350579334' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='3978' width='32' height='32'%3E%3Cpath d='M488 488V192a16 16 0 0 1 16-16h16a16 16 0 0 1 16 16v296H832a16 16 0 0 1 16 16v16a16 16 0 0 1-16 16H536V832a16 16 0 0 1-16 16h-16a16 16 0 0 1-16-16V536H192a16 16 0 0 1-16-16v-16a16 16 0 0 1 16-16h296z' p-id='3979'%3E%3C/path%3E%3C/svg%3E\");}background-image资源网站海量精美矢量图复制 svg 代码注意这里直接使用该url在小程序中是不行的，存在编码错误 下面是一个转编码的网站转换工具网站转换后的 就可以在小程序中使用粘贴到 wxss中必须使用Button 又想 实现 图标效果button有一些其他控件不具备的属性 比如 form 组件中 添加的 button 可以设置 重置表单 提交表单使用 text 就不行此时我们使用 button 包裹一个 text （前面的实现方法的text）代码wxml <button class=\"submitClass\" form-type=\"submit\" bindtap=\"submitForm\">            <text class=\"circle\"></text>        </button>        <button form-type=\"reset\" bindtap=\"resetForm\" class=\"submitClass\">            <text class=\"circleL\"></text>        </button>wxss.submitClass{  margin-top: 160rpx;  margin-bottom: 25rpx;  background: none !important;  color: #000 !important;}这里的button的wxss 让 button 没有边框 看得见内部的 text的样式。"}
{"title": "做好内容安全检测，和风险说「再见」！ ", "author": "Rolan", "pub_time": "2020-5-12 00:11", "content": "前言内容安全检测，是每一个小程序主都面临的“头疼”问题，轻则短暂性不可访问，重则永久封号，甚至关小黑屋。本文将为您详细说明，如何在小程序中对一段文本进行合法内容检测，以判断是否含有违法违规内容。本文重点为你讲述：内容安全检测常见应用场景及解决办法学会使用小程序·云开发的云函数+结合request-promise第三方库实现内容请求校验掌握如何在小程序端请求云函数（有别于传统的wx.request的方式(类似AJax)）在云开发的云函数端,利用第三方https请求库(request,request-promise),获取Access_token,以及向微信官方提供的内容检测接口发请求进行校验云函数端与小程序端错误码的处理01.背景无论是小程序还是自行开发的一些类似社交,带有用户自行产生内容的软件应用,例如:即时通讯,社群,论坛,音视频直播等,对于接入内容安全的检测是非常有必要的。对于小程序而言,这一点在审核上是非常严格的,净化言行,做一个知法守法的人很重要...接入内容安全检测,规避输入一些违法违规低俗等内容,避免辛辛苦苦开发出来的应用。被恶意上传反动言论或上传一些违规内容(文字/图片/视频等),导致小程序或应用被下架,或遭永久禁封,或个人及公司被公安机关打电话,约喝茶等,这样的话,就得不偿失了的。02.应用场景检测小程序用户个人文字资料是否违规针对特点词汇（如过于商业以及营销之类的词）可以进行过滤或禁止输入在内容发布之前自动检测用户发表的信息（包括评论、留言等）是否违规03.解决办法围绕如何处理内容安全检测问题，一般有3种方法：方案1****:引入第三方接口对内容进行校验(例如:百度AI内容审核平台,网易云盾等)方案2: 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口方案3: 小程序服务端提供的API进行校验每一种方法各有优劣势，具体如下图。解决方案优势劣势1引入第三方接口对内容进行校验前端同学只需按照官方提供的第三方接口文档,进行校验即可,无需后台介入,功能强大,覆盖范围广接口调用的频次有限制,收费2公司后台小伙伴自行开发文本,图片,音视频等内容审核接口后台小伙伴自己造轮子,根据自己的业务需求以及用户属性,自定义内容审核机制开发周期长,成本大,难以覆盖全面3调用小程序服务端提供的内容安全API进行校验简单,高效想不出来,因为相比前两种方案,对于不依赖后端接口的开发者来说,简直是雪中送炭在微信小程序生态下，官方提供了2种路径帮助用户解决内容检测问题，即使用服务器开发模式，通过HTTPS调用使用小程序·云开发，通过云函数或云调用来实现。服务器开发模式，相信大家都相对比较熟悉，在此就不再赘述。接下来为大家重点介绍，如何通过小程序·云开发的云函数实现内容安全检测。04.通过云开发的云函数+request-promise第三方库实现内容请求校验Step 1: 在小程序端先布局：完成静态页面。(pages文件夹下的文件都是属于小程序前端代码,每个文件夹目录代表的就是一个模块,一个页面)小程序前端wxml代码示例<view class=\"container\">\r\n  <textarea class=\"content\" placeholder=\"写点文字...\" bindinput=\"onInput\" auto-focus bindfocus=\"onFocus\" bindblur=\"onBlur\">\r\n  </textarea>\r\n</view>\r\n\r\n<view class=\"footer\">\r\n  <button class=\"send-btn\" size=\"default\" bind:tap=\"send\">发布</button>\r\n</view>小程序前端wxss代码示例/* pages/msgSecCheck/msgSecCheck.wxss */\r\n.container {\r\n  padding: 20rpx;\r\n}\r\n\r\n.content {\r\n  width: 100%;\r\n  height: 360rpx;\r\n  box-sizing: border-box;\r\n  font-size: 32rpx;\r\n  border: 1px solid #ccc;\r\n}\r\n\r\n.footer {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n  position: fixed;\r\n  bottom: 0;\r\n  box-sizing: border-box;\r\n  background: #34bfa3;\r\n}\r\n\r\n.send-btn {\r\n  width: 100% !important;\r\n  color: #fff;\r\n  font-size: 32rpx;\r\n}\r\n\r\nbutton {\r\n  width: 100%;\r\n  background: #34bfa3;\r\n  border-radius: 0rpx;\r\n}\r\n\r\nbutton::after {\r\n  border-radius: 0rpx !important;\r\n}经过wxml与wxss的编写后,UI最终长成这样Step 2: 完成小程序端业务逻辑的处理小程序端逻辑JS代码示例// pages/msgSecCheck/msgSecCheck.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    textareaVal: ''   // 页面中需要显示的数据,初始化定义在data下面\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n  // 监听表单时,数据有变化时\r\n  onInput(event) {\r\n    let textVal = event.detail.value;\r\n    this.setData({\r\n      textareaVal: textVal\r\n    })\r\n    \r\n  },\r\n\r\n  // 聚焦焦点时\r\n  onFocus() {\r\n    console.log('聚焦焦点时');\r\n  },\r\n\r\n  // 失去焦点时\r\n  onBlur(event) {\r\n    console.log(\"失去焦点时\");\r\n    // 前端可进行手动的弱校验,也可以在失去焦点时发送请求进行文本的校验,但是每次失去焦点就请求一次,这样是消耗云资源的,在发布时候与失去焦点做校验两者都可以\r\n\r\n\r\n  },\r\n\r\n  // 发布\r\n  send() {\r\n    console.log(\"触发发布按钮\")\r\n    wx.cloud.callFunction({ // 请求msgSecCheck1云函数\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: this.data.textareaVal // 需要向云函数msgSecCheck1传入的值\r\n      }\r\n\r\n    }).then(res => { // 成功时的响应返回结果\r\n      console.log(res);\r\n    }).catch(err => { // 失败时,返回的结果\r\n      console.error(err);\r\n    })\r\n    \r\n  }\r\n\r\n})Step 3 ：服务端逻辑处理。在小程序云函数端创建云函数msgSecCheck1,这个名字你可以自定义,与小程序前端请求的名字保持一致就可以了。选中云函数,右键并打开命令行终端安装request,request-promise，因为request-promise依赖于request,两个都要安装,最后一键上传部署就可以了npm install request\r\nnpm install request-promise如果遇到在小程序端请求云函数时,遇到类似下面的错误,找不到什么xxx模块之类的 先看错误码,然后在官方文档中找到该错误码代表的含义一看错误,没有找到模块,在云函数的目录下的package.json中查看是否有安装错误中提示的包的,要是没有的话,就安装一下就可以了的,同时记得每次更改后都要上传部署一下,也可以选择云函数中文件的增量上传接下来是将是本文的重点内容！Step 4 :通过云函数+****request-promise实现内容安全检测对于小程序开发,其实与web端开发也是类似,给元素绑定事件,然后获取元素,只是小程序端没有DOM,BOM的那一套东西,它是数据驱动视图的,吸收了Angular,Vue,React的各个框架的优点,形成了自己的一套规范。如果有这方面开发经验的小伙伴来说,平缓过度到小程序开发当中来,你会发现总会有惊人的相似,用的语言都是JavaScript,但是与web开发还是多少有很多差异的,这里就不拓展了。废话不多说,直接上代码 ：小程序前端逻辑代码：// 点击发送按钮,对输入的文本内容进行校验\r\n send() {\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1', // 云函数的名称\r\n      data: { // 需要向云函数传递过去的数据\r\n        content: this.data.textareaVal // 具体要检测的内容\r\n      }\r\n    }).then(res => { // 成功时,做什么事情\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n\r\n    }).catch(err => { // 失败时,做什么事情\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n\r\n      console.error(err);\r\n    })\r\n  }上面的代码还可以在优化一下,就是将请求云函数的代码封装成一个函数。如下所示,不封装也是没事的,只是我习惯性封装一下,如果其他地方也用到该云函数,那么直接调用，避免写重复的代码。下面是将请求云函数的部分核心代码：// 发布\r\n  send() {\r\n    // 请求msgSecCheck1云函数,对文本内容进行校验\r\n    this._requestCloudMsgCheck();\r\n  },\r\n\r\n  _requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal // 这里可以使用官方文档测试用例,特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }至于是在失去焦点事件时发送请求还是在点击发送按钮时发送请求,两种方式都可以。您也可以自定义文本校验,而我个人觉得在小程序端,失去焦点时,可以自定义做一些常规敏感词的弱校验,而在点击发送按钮时,做强校验 。如果是放在失去焦点时就立马请求,这样请求次数会增多,而放在点击发送按钮时进行校验,一定程度上可以减少小程序端频繁请求。接下来就是处理云函数端,使用request-promise请求请求微信内容安全接口的示例代码。/*\r\n *  Description: 利用第三方库request-promise请求微信内容安全接口\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\"; // 注意是你自己小程序的appid\r\nconst APPSECRET = \"\"; // 你自己小程序的appsecret\r\n// 安全校验接口\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n    return checkResponse;\r\n  } catch (err) {\r\n      console.error(err);\r\n  }\r\n}当你在小程序端输入文本,发送请求时,查看控制台下的结果时,功能是没有问题的。特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n完2347全dfji试3726测asad感3847知qwez到您可以根据官方文档中提供的测试用例,进行测试,看具体的返回结果的。（控制台错误码）(合规内容)云函数请求成功,看看错误信息的反馈,对于熟悉该错误码的人清楚该文本违规了,但是反馈不是很明显,即使当下自己很清楚,然而,在过几个月在回来看代码,你或许都不知道是啥意思。Step 5 ：错误码的正确处理方式对于处理错误码,返回具体的合适信息,对于调试代码,排查问题,也是非常重要 。这些错误码具体的含义,在官方文档里都有对应的解释,不用去记,去查文档就行。在面试中,有很多面试官喜欢问http相关状态码的问题,状态码有很多,也真的记不住,但是常见的错误http状态码还是要知道的,我觉得,具体知道怎么处理,怎么查文档就可以了。真正考验背后目的是,对于根据后端返回的状态码,判断接口哪里出了问题,定位是前端问题还是后端问题,这是一个非常常见的问题。如果你说你不知道,没有处理过,对于候选人,那肯定是没有信服力的,无论是成功状态还是失败状态,都是应该有对应的用户提示。05.完整文本安全校验示例代码/*\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\";\r\nconst APPSECRET = \"\";\r\n\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n\r\n    // 有必要根据错误码,确定内容是否违规\r\n    if (checkResponse.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: \"内容含有违法违规内容\",\r\n        data: checkResponse\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: \"内容OK\",\r\n        data: checkResponse\r\n      }\r\n    }\r\n  } catch (err) {\r\n    if (err.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    } else {\r\n      return {\r\n        code: 502,\r\n        msg: '调用msgCheckURL接口异常',\r\n        data: err\r\n      }\r\n    }\r\n  }\r\n}在云函数端,经过添加错误码的判断之后,在来看看小程序端发送的请求,返回的结果。（这与没有添加错误码判断,是不一样的,有具体的错误信息内容）至此,我们在小程序端可以根据这个返回的错误码或成功码,进行一些业务逻辑处理的,比如给一些用户提示,在数据插入数据库之前就做一些判断操作,只有内容合规时,才插入数据库,进入下一步的业务逻辑处理。_requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      const errcode = res.result.data.errcode;\r\n      // 检测到文本错误时,做一些业务\r\n      if (87014 === errcode) {\r\n         wx.showToast({ // 当内容违规时,做一些用户提示\r\n           title: '您输入的文本内容含有敏感内容,请重新输入',\r\n         })\r\n      }else {\r\n         // 成功时做其他业务操作\r\n      }\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }(当输入的内容有违规时,给一些用户提示或者阻止下一步操作等的)注意在云函数(后)端处理错误码与小程序端都是要进行处理的,两者不要混淆了的,小程序端最终的一些业务逻辑判断,是根据后端接口返回的状态,最终决定要做什么操作的。至此,通过request-promise库就完成了文本内容校验的问题。这个request,request-promise库非常实用,功能也非常强大,类似这种库,常见什么got,axios等之类的,都是支持promise风格的 处理方式大同小异,大家可以去npm或github上阅读相关使用文档的。06.结语在小程序中有多种解决方案,推荐使用小程序端请求云开发云函数的方式,无论是不使用云函数方式,自己有后端服务,获取access_token都应该是从后端返回给前端的。而小程序的秘钥 AppSecret是不应该放在小程序端的,那样不安全的,无论是服务器开发模式还是小程序·云开发模式,都绕不过后台请求微信提供的内容安全接口,然后在返回给小程序端 。其实在小程序·云开发中,还提供了一种更简便的方法,那就是云调用,它是小程序·云开发提供的在云函数中调用微信开放接口的能力,只需简单的进行配置一下就可以了。限于篇幅所致,放在下一节介绍。reference:方案1参考链接:微信内容安全:https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html云调用https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#%E4%BA%91%E5%87%BD%E6%95%B0百度文本审核https://ai.baidu.com/tech/textcensoring网易云盾https://dun.163.com/product/text-detection公众号：腾讯云云开发腾讯云云开发： https://cloudbase.net云开发控制台： https://console.cloud.tencent.com/tcb?from=12304"}
{"title": "小程序canvas开发水果老虎机 ", "author": "Rolan", "pub_time": "2020-2-8 00:53", "content": "在这个超长假期中，无聊。。。，所以动手做一个早就计划要做的小玩意， 水果老虎机 ，嗯，这是一个小程序而不是小游戏...使用结构还是canvas？使用模板结构(view)生成水果盘的好处一是用户可自定义产出 n x n 的定制化老虎机，二是容易通过算法样式生成布局，三是通过 wx.selectQueryAll 的方法能够很方便的抓到定位数据。但，问题是动画性能过于孱弱，如图构建一个 7x7 的水果盘，动画性能估计会惨不忍睹，而且纯粹模板结构无论使用 animation 动画方法还是 css 的keyframe的动画方法得到的动画效果都非常差(测试过的结论)，还有是已知的动画方法可控性很差使用canvas来生成水果盘好处是动画性能很好(canvas2d)，但是定制性和扩展性比较差so综上考虑，使用模板(view)布局，使用canvas来实现动画。既保证了组件的性能，同时定制型，扩展性也很好准备计时器方法动画的生成离不开计时器方法，settimeout/setinterval这两兄弟真的不够看啊，问题还多，做过web开发的一定都知道 window.requestAnimationFrame ，这货在小程序的计时器方法中不存在，好在 canvas2d 中可以使用 Canvas.requestAnimationFrame(function callback) 方法来实现准备运动算法在水果老虎机中，激活状态会沿着四方的水果盘做非线性运动(easeInOut比较好用)，需要基础的运动算法来计算实际的运动距离。在 animation 动画方法中，我们可以使用 ease-in/ease-out 等缓动算法来实现动画效果，但在这里必须要借助 tween.js 中的缓动算法来实现运动效果(因为需要控制运动节点)。你会不会想到用css的keyframe动画来做这个运动效果，经过我的测试，css的动画和animation的动画会在每一条边上实现一次(ease)缓动运动(很奇怪的效果)推荐这篇文章使用其中一个，节省代码量/*\r\n * Tween.js\r\n * t: current time（当前时间）；\r\n * b: beginning value（初始值）；\r\n * c: change in value（变化量）；\r\n * d: duration（持续时间）。\r\n */\r\n// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n复制代码tween算法是以时间为基准(时间比率 = 距离比率)来计算单位时间的实际运动距离布局以上面的图为例，我们需要做一个 7 x 7 的水果盘，实际有效的奖品格子数为 7*4-4 共24个有效格子有效格子算法js// 0-6 第一行所有格子全部有效  \r\n// 21-27 最后一行所有格子全部有效  \r\n// 中间部分 i%7===0 和 i%7 === (7-1) 有效\r\n// 算法源码有点无聊，依据上述思路，即可遍历28个格子并标识奖品格子valide=true\r\n// 可以扩展想一想 6x6 5x5，思路是一样的\r\n复制代码wxml<view class=\"fruits-container\" >\r\n    <view class=\"fruits-table\" >\r\n        <block wx:for=\"{{ary}}\" wx:key=\"index\" >\r\n            <view wx:if=\"{{item.valide}}\" class=\"valide\">{{item.title}}</view>\r\n            <view wx:else class=\"in-valide\"></view>\r\n        </block>\r\n    </view>\r\n    <canvas type=\"2d\" .... />\r\n</view>\r\n复制代码样式只节选关键样式，目的是让canvas覆盖在水果盘上，长宽一致.fruits-container {\r\n    position: relative;\r\n    width: 400px;\r\n    height: 400px;\r\n    ...\r\n}\r\n\r\n.fruits-table {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n    ...\r\n}\r\n复制代码抓取位置信息canvas的绘制需要X轴, Y轴的精确信息，可以使用 wx.createSelectorQuery 方式抓取类名为‘valide’的 view (奖品格子)的位置信息let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    console.log(ret[0]) // top, left, right, bottom, width, height\r\n    console.log(ret[1]) // top, left, right, bottom, width, height\r\n    ...\r\n    ...\r\n    console.log(ret[23]) // top, left, right, bottom, width, height\r\n})\r\n复制代码得到每一个奖品格子的位置信息后，就可以使用canvas的 fillRect 方法来绘制激活状态了。绘制一个激活状态let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    let {top, left, right, bottom, width, height} = ret[0]\r\n    const canvasQuery = wx.createSelectorQuery()\r\n    canvasQuery.select('#fruit-canvas')\r\n    .fields({ node: true, size: true })\r\n    .exec((res) => {\r\n        const canvas = res[0].node\r\n        const ctx = canvas.getContext('2d') \r\n        let x = top\r\n        let y = left\r\n        let dx = width\r\n        let dy = height\r\n        ctx.shadowOffsetX = 2\r\n        ctx.shadowOffsetY = -2\r\n        ctx.shadowColor = 'red'\r\n        ctx.shadowBlur = 50\r\n        ctx.lineWidth = 5\r\n        ctx.strokeStyle = 'red'\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n        ctx.strokeRect(x, y, dx, dy)\r\n    })\r\n})\r\n复制代码跑起来已经绘制了一个激活状态，接下来使它能够简单动起来// 抽象激活方法  \r\nfuncton rect(point, canvas){\r\n    let {x, y, dx, dy} = getPosition(point)\r\n    ctx.shadowOffsetX = 2\r\n    ctx.shadowOffsetY = -2\r\n    ...\r\n    ...\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height) // 擦除整个水果盘\r\n    ctx.strokeRect(x, y, dx, dy) // 绘制激活区域\r\n}\r\n\r\nfunction run(){\r\n    setTimeout(()=>{\r\n        if (ret.length) {\r\n            let point = ret.shift()\r\n            rect(point, canvas)\r\n            run()\r\n        }\r\n    }, 100)\r\n}\r\n复制代码执行run方法后可以看到水果盘的激活状态一步一步的往前走(100毫秒)，拖拉机终于可以启动了配上运动算法经过上面的试验我们终于可以看到基本的运动效果了，接下来配上运动算法和计时器方法// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n\r\nlet start = 0  // 开始时间\r\nlet begin = 0  // 开始奖品位置\r\nlet end = 23  // 终点位置，这里跑一圈\r\nlet during = 5000 // 运动总时间\r\n\r\n// 1000/60 ≈ 17，\r\n// 17毫秒即表示屏幕60帧刷新率每秒 ≈ requestAnimationFrame计数频率(一般情况)  \r\nconst steper = () => {\r\n  // left为位移距离\r\n  // 老虎机的运动位移是节点位移，不是精确位移\r\n  // 所以这里用parseInt处理，只取整数部分\r\n  // 数据变化为 0,1,2,3,4,5...23\r\n  // 间隔时间/距离由easeInOutQuart算法计算\r\n  var left = easeInOutQuart(start, begin, end, during);\r\n  let idx = parseInt(left)\r\n  start = start + 17; \r\n  if (idx <= end) {\r\n    let point = this.ret[idx] // 取节点位置信息\r\n    this.rect(point) // 绘制\r\n  }\r\n  \r\n  // 时间递增\r\n  if (start <= during) {\r\n    this.ctx.requestAnimationFrame(steper); // 计时器\r\n  } else {\r\n    // 动画结束，这里可以插入回调...\r\n    // callback()...\r\n  }\r\n};\r\n\r\nsteper(); // 启动\r\n复制代码以上为我的小程序水果老虎机的基本开发思路"}
{"title": "小程序订阅消息用户拒绝/关闭后，如何引导用户再开启？并获得用户的操作呢？ ... ", "author": "Rolan", "pub_time": "2020-3-5 00:15", "content": "前言有些时间没折腾小程序了，话说年前小程序就发布了消息，于1月10日会下线模板消息下发功能，所有的订阅消息都要用户手动触发确认同意，这可就太难了，之前的\twx.openSetting 、\twx.getPhoneNumber 、\twx.getUserInfo 等等API的调整，可把我折腾惨了，这次又来……难道直接js调用，不爽吗？非要整手动确认，爽是肯定的，但如果从一个用户的角度出发，自己啥都没干，你就把我信息获取了、天天给我推一堆垃圾信息，那肯定不爽了，所以从这角度看，微信的调整也是为了尊重用户的隐私，毕竟用户第一嘛今天主要是想分享一下，今天在处理这个订阅消息逻辑时，遇到当\t用户拒绝 后，如何重新引导开启 「订阅消息」通知的问题，并在\t开启后获取到它的状态如果你处理过小程序的订阅消息，应该是知道的，在用户拒绝或关闭消息总开关之后，我们引导用户手动开启「订阅消息」功能（也就是\topenSetting API的调用回调里，是拿不到\tscope.subscribeMessage 状态的），开始我也纠结了很久，百度、google都用上了，同样发现很多的同学也有遇到这样的问题，而都没有找到解决方案，最后在我快要放弃的时候却突然灵光一闪，想到了个办法，所以抖胆BB几句，分析一下：温馨提示：书读的少，却又喜欢瞎BB几句，内容仅为个人解决方案的思路，仅供参考，不足之处请见谅，勿喷，谢谢～授权API示例首先来看下调用的示例：wx.requestSubscribeMessage({\r\n  tmplIds: ['模版id'],\r\n  success (res) {\r\n\r\n  }\r\n})同时官方也说了，\tsuccess 回调的模版对应有三种状态：accept = 同意reject = 拒绝ban = 后台封禁fail 也有对应的状态码，如下：本次要讲的是\terrorCode 20004 与\treject 状态时，根据以往经验，如果拒绝了，我们肯定是使用直接使用\topenSetting ,引导用户进行手动开启授权（），比如：//以微信运动为例\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  components = {\r\n    Toast: Toast,\r\n    Modals: Modals\r\n  };\r\n  methods = {\r\n  };\r\n  data = {\r\n    signHistory: []\r\n  };\r\n  getRunData() {\r\n    wx.getWeRunData({\r\n      success: res => {\r\n        ……处理运动步数逻辑\r\n      }\r\n    });\r\n  }\r\n  setAuth() {\r\n    wx.getSetting({\r\n      success: res => {\r\n        //第一步，检测是否有授权 - 没有授权\r\n        if (!res.authSetting['scope.werun']) {\r\n          //第二步，开始授权，但这里有一个坑点（腾讯的bug），之前授权过但是是拒绝，所以会进入失败\r\n          wx.authorize({\r\n            scope: 'scope.werun',\r\n            success: () => {\r\n              this.getRunData();\r\n            },\r\n            fail: () => {\r\n              //第三步，引导用户，手动引导用户点击按钮，去设置页开启，## Modals是自定义组件\r\n              this.$invoke('Modals', '__modalConfirm__', [\r\n                '检测到您没有打微信运动的权限，是否去设置？',\r\n                'openSetting',\r\n                //第四步，进入设置页的回调 - 成功\r\n                res => {\r\n                  let { authSetting } = res.detail;\r\n                  if (authSetting['scope.werun']) {\r\n                    this.getRunData();\r\n                  } else {\r\n                    this.$invoke('Toast', '__warning__', [\r\n                      `您没有同意授权微信运动，获取步数失败`\r\n                    ]);\r\n                  }\r\n                },\r\n                //第五步，点击取消按钮的回调\r\n                () => {\r\n                  this.$invoke('Toast', '__warning__', [\r\n                    `您已拒绝微信运动授权，无法获取步数`\r\n                  ]);\r\n                }\r\n              ]);\r\n            }\r\n          });\r\n        } else {\r\n          //第六步，已经授权直接进入保存逻辑\r\n          // console.log(\"授权了\")\r\n          this.getRunData();\r\n        }\r\n      }\r\n    });\r\n  }\r\n}上面代码执行截图如下：上述代码，\tthis.$invoke('Modals'……) 部分为自定义弹窗，即引用用户确定，去设置页，requestSubscribeMessage 问题点但是 在\topenSetting 的回调里，是没有\tscope.subscribeMessage 这一项的，下面是列出的\tscope 列表 官方清单（\t文档地址 ）：//提交订阅消息示例\r\n\r\n\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  setClock(e) {\r\n    let that = this;\r\n    if (wx.requestSubscribeMessage) {\r\n      wx.requestSubscribeMessage({\r\n        tmplIds: [pushReservationTmplIds],\r\n        success(res) {\r\n          if (res[pushReservationTmplIds] === 'accept') {\r\n            //发起请求……\r\n          } else if (res[pushReservationTmplIds] === 'reject') {\r\n            // 用户历史操作有设置了拒绝 or 关闭了订阅消息的主（总）开关，导致无法推送\r\n            that.guideOpenSubscribeMessage();\r\n          } else {\r\n            wx.showToast({\r\n              title: '授权订阅消息有误',\r\n              icon: 'none'\r\n            });\r\n          }\r\n        },\r\n        fail(res) {\r\n\r\n          // 20004:用户关闭了主开关 或在 消息通知 里 “拒绝接收”操作，无法进行订阅,引导开启\r\n          if (res.errCode == 20004) {\r\n            console.log(res, 'fail:用户关闭了主开关，无法进行订阅,引导开启---');\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      wx.showToast({\r\n        title: '请更新您微信版本，来获取订阅消息功能',\r\n        icon: 'none'\r\n      });\r\n    }\r\n  }\r\n  guideOpenSubscribeMessage() {\r\n    //引导用户，手动引导用户去设置页开启，\r\n    this.$invoke('Modals', '__modalConfirm__', [\r\n      '检测到您没有开启订阅消息的权限，是否去设置？',\r\n      'openSetting',\r\n      res => {\r\n        console.log('openSetting的回调数据：', res);\r\n        //但是这个回调数据里，并没有 「订阅消息」 相关 open/close 的状态返回\r\n\r\n      },\r\n      //用户点击了取消按钮\r\n      () => {\r\n        // console.log(\"取消了\")\r\n        this.$invoke('Toast', '__warning__', [\r\n          `您已拒绝订阅消息授权，无法预约`\r\n        ]);\r\n      }\r\n    ]);\r\n}上图为\topenSetting 的回调数据，而网上说回调里不做任何处理，用户是否有手动开启，则让提示让他再手动点击一次业务按钮，如果有开启，则回到最初的逻辑，订阅消息成功，否则则又循环进入\topenSetting 设置页，俗称“死缠烂打授权法”，这当然不失为一种方法，但体验不是最好，对于追求完美的我来说，不能接受，继续寻找更好的方案，把官方文档来回看，终于发现了新大陆，——\twx.getSetting文档有有这么一个属性：\tsubscriptionsSetting ，感谢苍天，终于让我看到了\t订阅消息 相关的东西，//官方示例\r\nwx.getSetting({\r\n  withSubscriptions: true,\r\n  success (res) {\r\n    console.log(res.authSetting)\r\n    // res.authSetting = {\r\n    //   \"scope.userInfo\": true,\r\n    //   \"scope.userLocation\": true\r\n    // }\r\n    console.log(res.subscriptionsSetting)\r\n    // res.subscriptionsSetting = {\r\n    //   mainSwitch: true, // 订阅消息总开关\r\n    //   itemSettings: {   // 每一项开关\r\n    //     SYS_MSG_TYPE_INTERACTIVE: 'accept', // 小游戏系统订阅消息\r\n    //     SYS_MSG_TYPE_RANK: 'accept'\r\n    //     zun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject', // 普通一次性订阅消息\r\n    //     ke_OZC_66gZxALLcsuI7ilCJSP2OJ2vWo2ooUPpkWrw: 'ban',\r\n    //   }\r\n    // }\r\n  }\r\n})在\twx.getSetting 的回调里，有一项\tmainSwitch ，还有一项\twithSubscriptions: true ，最后回调里还能一项\tzun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject' ，到这里，但它也只是在\tgetSetting 方法里啊，跟\topenSetting 没有扯上任何关系，怎么办？其实道理很简单，但人有时候就是这样，思维如果没有转换过来，你可以就会一直杠在那个死胡同里出不来，openSetting 回调里取不到状态，\t那么我们是否可以在它的回调里，再做一次\tgetSetting 的调用里呢？\t，取\tgetSetting 回调里的状态来判断，刚才用户在设置页的行为操作，直接看示例吧：//提交订阅消息示例\r\n\r\nconst pushReservationTmplIds = 'PVC_DBcvvdtffd1fO0vdS8YpSe0c7Br3QW54';\r\n\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  submitClock() {\r\n    fetchJson({\r\n      type: 'POST',\r\n      url: '/api/steps/clock',\r\n      data: {\r\n      },\r\n      success: res => {\r\n        wx.showToast({\r\n          title: '预定成功',\r\n          icon: 'success',\r\n          duration: 2000\r\n        });\r\n      }\r\n    });\r\n  }\r\n  setClock(e) {\r\n    let that = this;\r\n    if (wx.requestSubscribeMessage) {\r\n      wx.requestSubscribeMessage({\r\n        tmplIds: [pushReservationTmplIds],\r\n        success(res) {\r\n          if (res[pushReservationTmplIds] === 'accept') {\r\n            that.submitClock();\r\n          } else if (res[pushReservationTmplIds] === 'reject') {\r\n            // 用户历史操作有设置了拒绝 or 关闭了订阅消息的主（总）开关，导致无法推送\r\n            // console.log(res, '0 拒绝 or 关闭了订阅消息的主（总）开关---');\r\n            that.guideOpenSubscribeMessage();\r\n          } else {\r\n            wx.showToast({\r\n              title: '授权订阅消息有误',\r\n              icon: 'none'\r\n            });\r\n          }\r\n        },\r\n        fail(res) {\r\n          // 20004:用户关闭了主开关，无法进行订阅,引导开启\r\n          if (res.errCode == 20004) {\r\n            // console.log(res, 'fail:用户关闭了主开关，无法进行订阅,引导开启---');\r\n            that.guideOpenSubscribeMessage();\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      wx.showToast({\r\n        title: '请更新您微信版本，来获取订阅消息功能',\r\n        icon: 'none'\r\n      });\r\n    }\r\n  }\r\n  guidSubscribeMessageAuthAfter() {\r\n    //引导用户 开启订阅消息 之后，「openSetting」 接口暂时不会返回，用户手动设置后的状态，所以采用「getSetting」接口重新进行查询\r\n    wx.getSetting({\r\n      withSubscriptions: true,\r\n      success: res => {\r\n        let {\r\n          authSetting = {},\r\n          subscriptionsSetting: { mainSwitch = false, itemSettings = {} } = {}\r\n        } = res;\r\n\r\n        if (\r\n          (authSetting['scope.subscribeMessage'] || mainSwitch) &&\r\n          itemSettings[pushReservationTmplIds] === 'accept'\r\n        ) {\r\n          this.submitClock();\r\n          // console.log('用户手动开启同意了，订阅消息');\r\n        } else {\r\n          this.$invoke('Toast', '__warning__', [\r\n            `您没有同意授权订阅消息，预约领取失败`\r\n          ]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  guideOpenSubscribeMessage() {\r\n    //引导用户，手动引导用户去设置页开启，\r\n    this.$invoke('Modals', '__modalConfirm__', [\r\n      '检测到您没有开启订阅消息的权限，是否去设置？',\r\n      'openSetting',\r\n      //用户点击了确定按钮，进入设置页的回调\r\n      res => {\r\n        console.log('openSetting的回调数据：', res);\r\n        this.guidSubscribeMessageAuthAfter();\r\n      },\r\n      //用户点击了取消按钮\r\n      () => {\r\n        // console.log(\"取消了\")\r\n        this.$invoke('Toast', '__warning__', [\r\n          `您已拒绝订阅消息授权，无法预约领取`\r\n        ]);\r\n      }\r\n    ]);\r\n  }\r\n}结尾到这里，\twx.requestSubscribeMessage 的问题，也就得到了解决，看到网上有贴子在喷\trequestSubscribeMessage API的设计，比如：\twx.requestSubscribeMessage的接口参数结构设计反人性，实习生设计的吗？ ,其实我也想说这么庞大的一个生态体系，更新方案就考虑的这么不全面吗？还是说就是这么反人类？\tgetSetting 里给\trequestSubscribeMessage 的相关状态，\topenSetting 里又压根没有，然后又把它的引导开启逻辑UI也放在设置页里面，我就郁闷了，今天的分享，为我个人的解决思路方案，如有不足之处，请指出，勿喷～谢谢！！"}
{"title": "小程序悬浮按钮，悬浮导航球 ", "author": "Rolan", "pub_time": "2020-3-10 00:37", "content": "一个开源的悬浮按钮组件，小程序原生支持。一直很喜欢华为的导航按钮，能够完美适合大屏手机，自由停放位置，不论是左手习惯还是右手习惯，都很方便(可能我手比较小，左右上角够不着）。支持功能支持自由拖动，停放支持自定义事件(单击，双击，长按)支持自定义导航球中间的文字/图片开发难点使用wxs悬浮球的开发思路比较简单，一个view，样式 position:fixed ，支持拖动。在web开发中，我们能够比较容易实现这样的功能。要想在小程序中实现高性能的交互动画(touch类)，一定要了解如何使用页面的 wxs 这个残疾JS来操作对象(调试很麻烦，js极度残疾)<wxs module=\"tool\">\r\n  function tStart(e, ins){}\r\n  \r\n  function tMove(e, ins){\r\n    e.instance.setStyle('transform: translate3d(...)')  \r\n    // e.instance指向当前操作对象\r\n    // setStyle 设置该对象的style样式\r\n  }\r\n  \r\n  function tEnd(e, ins){}\r\n  \r\n  module.exports = {\r\n    tStart: tStart,\r\n    tMove: tMove,\r\n    tEnd: tEnd\r\n  }\r\n</wxs>\r\n\r\n<view catch:touchstart=\"{{tool.tStart}}\" catch:touchmove=\"{{tool.tMove}}\" ... />\r\n复制代码这里使用catch，而不是使用bind来绑定事件，事件指向 wxs 的方法。考虑到悬浮导航球是作为工具在其他场景中使用，为了不会污染touch事件，或者导致页面不必要的滚动。位移距离手机宽高不一致，即x轴的运动距离小于y轴运动距离(单位时间)，假定手机宽高比为1:2，x轴运动1px，y轴则运动了2px，我们可以设置一定的系数，使得拖动效果符合预期。监听事件最终的事件响应一定是在page页面(或者组件内部)实现事件监听，wxs有一套事件调用机制function tStart(e, ins){\r\n  ins.callMethod('onTouchStart', e)\r\n  // 调用当前组件/页面在逻辑层（App Service）定义的函数。funcName表示函数名称，args表示函数的参数\r\n}\r\n复制代码"}
{"title": "全平台（Vue、React、微信小程序）任意角度旋转 图片裁剪组件 ... ", "author": "Rolan", "pub_time": "2020-3-5 00:34", "content": "SimpleCrop 目前是 全网唯一 支持裁剪图片任意角度旋转、交互体验 媲美原生客户端 的 全平台 图片裁剪组件。项目地址： github.com/newbieYoung… 。特性及优势和目前流行的图片裁剪组件相比，其优势在于以下几点：裁剪图片支持任意角度旋转；支持 Script 标签、微信小程序、React、Vue 等多种开发模式；支持移动和 PC 设备；支持边界判断、当裁剪框里出现空白时，图片自动吸附至完全填满裁剪框；移动端缩放以双指中心为基准点；交互体验媲美原生客户端。示例微信小程序示例移动端示例左侧是 IOS 系统相册中原生的图片裁剪功能，右侧为 SimpleCrop 移动端示例。可以扫描二维码体验：或者访问以下链接：newbieyoung.github.io/Simple-Crop…PC 示例链接如下：newbieyoung.github.io/Simple-Crop…关键实现要实现 任意角度旋转 、 双指中心缩放 、 边界判断 、 自动吸附 等功能，关键点如下：1、屏幕坐标系和变换基准点在裁剪图片场景中，存在两个坐标系，其一是裁剪图片所代表的实际尺寸坐标系，其二是裁剪框显示到屏幕上所代表的屏幕坐标系；后续进行 transform 变换计算和位置判断时，为了计算方便，需要把裁剪图片的尺寸以及位置从实际坐标系转换为屏幕坐标系。另外当对裁剪图片进行 transform 变换时，变换基准点默认为其中心点，对应 CSS 的 transform-origin 为 50% 50%。2、获取实时坐标首先需要实时获取裁剪图片进行 CSS Transform 变换后的新坐标，只有在实时获取变换后的新坐标的前提下才能结合裁剪框坐标进行越界、吸附等判断；在计算 CSS Transform 变换后的新坐标时需要注意选取的屏幕坐标系和 CSS Transform 坐标系的差别，比如示例中以黑色边框中心为坐标原点，水平向左为 X 轴正方向，垂直向上为 Y 轴正方向；但是 CSS Transform 的坐标系垂直向下为 Y 轴正方向和上述规定的坐标系 Y 轴正方向是相反的，因此在获取 CSS Transform 变换矩阵之后求实时坐标时还需要进行镜像变换。详细计算过程可以查看 CSS3 2D Transform Matrix 。3、旋转适配缩放裁剪图片任意角度旋转时需要进行适当的放大才能保证裁剪框不超出，因此就需要先计算裁剪框哪些点超出，然后根据超出的点计算刚好包含的放大倍数。当两个矩形位置关系任意变换时计算相互之间有哪些点超出有两种方案：其一：图中左侧红色矩形代表裁剪图片，黑色矩形代表裁剪框，如图所示裁剪框顶点 A 超出了裁剪图片。连接矩形四个顶点和判断点，然后计算四条连线之间的夹角，如果夹角之和小于 360 度，那么该判断点在矩形外；反之如果夹角之和等于 360 度，那么该判断点在矩形内。a1 + a2 + a3 + a4 < 360\r\nb1 + b2 + b3 + b4 = 360\r\n复制代码其二：图中黑色矩形表示裁剪图片，点 A 表示裁剪框中超出裁剪图片的某个顶点。连接矩形中心点和判断点，然后计算中心点和判断点向量在矩形边框向量上的投影长度（L1、L2），只要两个投影长度中有任意投影长度大于其投影边框长度（H1、H2）的一半即说明该点在矩形外。另外还可以根据投影长度和其投影边框长度的比例计算出矩形恰好包含该点的放大系数，也就是示例图中的 S 变量。最后旋转图片时除了要进行适当的放大，保证裁剪框不超出以外，还可以在裁剪图片中心点没有变动时进行适当的缩小，去掉多余间隙，进一步提升交互体验。缩小系数的计算原理和放大系数的计算原理类似，均是连接判断点和中心点，然后根据边框投影长度计算。大矩形为裁剪图片，小矩形表示裁剪框，O 表示裁剪图片中心点。4、双指中心位移由于默认裁剪图片的变换基准点为其中心点，这么处理虽然计算方便，但是会对双指缩放造成一定的困难；因为双指操作时双指中心并不一定是裁剪图片中心。解决方案需要先求出两个不同基准点的位移差，然后在进行缩放变换之后再进行位移变换。5、缩放适配变换在旋转裁剪图片时可以对其进行适当得放大和缩小从而保证裁剪框不会超出裁剪图片；但是在双指操作缩放裁剪图片却不能这么做，因为适配缩放会和用户的操作缩放冲突，因此需要采用移动裁剪图片的方式保证裁剪框不超出裁剪图片。当裁剪图片进行位移变换之后可以包含裁剪框，就只需要计算位移向量；红色矩形为裁剪图片，黑色矩形为裁剪框。但是还有一种情况即裁剪图片进行位移变换之后不能包含裁剪框，如下：红色实线矩形为裁剪图片，黑色矩形为裁剪框，红色虚线矩形为进行放大之后恰好包含裁剪框的裁剪图片。此时说明用户的操作缩放超出了组件的合法限制范围，可以加入适配缩放了；这时候就需要先计算裁剪图片恰好包含裁剪框的放大系数，然后再进行位移变换。"}
{"title": "制作微信小程序音乐播放器踩的坑! ", "author": "Rolan", "pub_time": "2020-3-9 00:21", "content": "ps: 搭配思维导图食用更佳!源码链接:在onload中,必须在获取云数据库的数据时给innerAudioContext.src赋默认值Page({\r\n  onLoad: function (options) {\r\n        album.get().then(res => {//获取云数据库的数据\r\n          this.setData({\r\n            albums: res.data\r\n          })\r\n          innerAudioContext.src = res.data[this.data.currentIndex].link\r\n        })\r\n        //错误innerAudioContext.src = this.data.albums[this.data.currentIndex].link \r\n        //此处console.log(this.data.albums)为[]因为album.get()是异步操作\r\n    }\r\n})\r\n复制代码解决监听音频进度更新onTimeUpdate不执行更新onTimeUpdate不触发和onWaiting有关,当拖动进度\\播放完毕\\切歌等重新加载音乐时，都会 触发onWaiting，然后onTimeUpdate就无法执行 .解决方法是:暂停音乐后再定时(延迟时间要充足!)播放innerAudioContext.pause()//暂停音乐\r\n      //音乐跳转到指定位置\r\n      innerAudioContext.seek((e.detail.value * innerAudioContext.duration) / 100)\r\n      setTimeout(() => {\r\n        innerAudioContext.play()//播放音乐\r\n      }, 500)\r\n复制代码实现图片原地旋转动画developers.weixin.qq.com/miniprogram…const innerAudioContext = wx.createInnerAudioContext()\r\nconst animation = wx.createAnimation({//创造动画\r\n  duration: 500,\r\n  timingFunction: 'linear',\r\n})\r\nthis.data.timer = setInterval(() => {//封面旋转\r\n        animation.rotate(this.data.rotate_deg).step()\r\n        this.setData({\r\n          rotate_deg: this.data.rotate_deg + 45,\r\n          animationData: animation.export()\r\n        })\r\n      }, 500)\r\n复制代码获取当前歌曲信息blog.csdn.net/qq_41183241…方法用法wx:for在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件wx:key指定列表中项目的唯一的标识符wx:key=\"字符串\"代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。wx:key=\"*this\"代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。wx:for-item指定数组当前元素的变量名wx:for-index可以指定数组当前下标的变量名data-*组件上触发的事件时，会发送给事件处理函数<block wx:for=\"{{albums}}\" wx:key=\"index\" >\r\n    <image src=\"{{item.cover}}\" class=\"item_cover\" bindtap=\"imgClick\" data-index=\"{{index}}\" wx:for-index=\"index\"></image>\r\n  </block> \r\n复制代码imgClick:function (e){\r\n    this.setData({\r\n      currentIndex: e.target.dataset.index\r\n    })\r\n    ...\r\n  },\r\n复制代码如何如何实现切割保证进度条正常更新-暂停播放(用原生的还是自制的)developers.weixin.qq.com/community/d…如何获取网易云音乐链接网易云音乐外链(其中id改为相应的歌曲ID即可): music.163.com/song/media/…实现歌曲循环播放第一首切上一首: ①当前索引 = 歌单长度; 当前索引-1最后一首切下一首: ①当前索引 = (当前索引 + 1) % 歌单长度prev_song: function(){//上一首\r\n    if (this.data.currentIndex == 0) {//判断是否是第一首歌\r\n      this.data.currentIndex = this.data.albums.length\r\n    }\r\n    this.setData({\r\n      currentIndex: this.data.currentIndex - 1\r\n    })\r\n    ...\r\n  },\r\n  next_song: function () {//下一首\r\n    var len = this.data.albums.length//歌曲列表长度\r\n    var x = (this.data.currentIndex + 1) % len//下一首歌的索引\r\n    this.setData({\r\n      currentIndex: x\r\n    })\r\n    ...\r\n  },\r\n复制代码"}
{"title": "微信小程序上传图片至OSS的一些个人总结 ", "author": "Rolan", "pub_time": "2020-3-5 00:42", "content": "这两天修改公司小程序的一些功能，发现上传图片至OSS失败，便一直寻找出现了什么问题，最后发现是policy过期，更改后发现相应的signature也要改，因为需要特定的处理才能生成signature，当时好一顿查资料，最后算出signature，在这里做一下总结，也借签了一位作者的文章。 https://segmentfault.com/a/11...首先，准备工作:1.下载Base64.js,hmac.js,sha1.js,crypto.js相关算法 点击 。2.创建一个用于计算的policy和signa的js文件，我们只要输出结果即可。我们起名为ceshi.js。3.在ceshi.js引入我们下载的4个算法文件。const Base64 = require('./Base64.js');\r\n\r\nrequire('./hmac.js');\r\nrequire('./sha1.js');\r\nconst Crypto = require('./crypto.js');一、先转码Policy在ceshi.jslet date = new Date();\r\n  date.setHours(date.getHours() + 87677);\r\n  let srcT = date.toISOString();\r\n  const policyText = {\r\n    \"expiration\": srcT, //设置该Policy的失效时间\r\n    \"conditions\": [\r\n      [\"content-length-range\", 0, 5 * 1024 * 1024] // 设置上传文件的大小限制,5mb\r\n    ]\r\n  };\r\n  const policyBase64 = Base64.encode(JSON.stringify(policyText));使用此js可计算出一个policy二、计算signatureconst accesskey = 'QSZ***98V1DW'; // 为了保密我做了处理，大家输入自己公司的accesskey即可。\r\n  const bytes = Crypto.HMAC(Crypto.SHA1, policyBase64, accesskey, {\r\n    asBytes: true\r\n  });\r\n  const signature = Crypto.util.bytesToBase64(bytes);\r\n  console.log(policyBase64);\r\n  console.log(\"myfunc....\");\r\n  console.log(signature);这样我们便可计算出signature啦。三、全部代码为ceshi.jsconst Base64 = require('./Base64.js');\r\n\r\nrequire('./hmac.js');\r\nrequire('./sha1.js');\r\nconst Crypto = require('./crypto.js');\r\nfunction myfunc() {\r\n  let date = new Date();\r\n  date.setHours(date.getHours() + 87677);\r\n  let srcT = date.toISOString();\r\n  console.log(srcT);\r\n  const policyText = {\r\n    \"expiration\": srcT, //设置该Policy的失效时间\r\n    \"conditions\": [\r\n      [\"content-length-range\", 0, 5 * 1024 * 1024] // 设置上传文件的大小限制,5mb\r\n    ]\r\n  };\r\n  const policyBase64 = Base64.encode(JSON.stringify(policyText));\r\n  const accesskey = 'QSZYryqudf8AAzyoAoJbeCIP98V1DW';\r\n  const bytes = Crypto.HMAC(Crypto.SHA1, policyBase64,    accesskey, {\r\n    asBytes: true\r\n  });\r\n  const signature = Crypto.util.bytesToBase64(bytes);\r\n  console.log(policyBase64);\r\n  console.log(\"myfunc....\");\r\n  console.log(signature);\r\n}\r\nmodule.exports.myfunc = myfunc;四、调用ceshi.js新建oss.jsconst ceshi = require('./ceshi.js');\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function (options) {\r\n    ceshi.myfunc();\r\n  },\r\n  onReady: function () {\r\n  },\r\n  onShow: function () {\r\n  },\r\n  onHide: function () {\r\n  },\r\n  onUnload: function () {\r\n  },\r\n  onPullDownRefresh: function () {\r\n\r\n  },\r\n  onReachBottom: function () {\r\n  },\r\n  onShareAppMessage: function () {\r\n\r\n  }\r\n})五、文件目录六、结果以上是全部内容，感谢之前看过的相似文章，在此我自己做了相关总结，希望能帮大家解决问题！谢谢！"}
{"title": "微信小程序使用字体图标 ", "author": "Rolan", "pub_time": "2020-3-16 00:13", "content": "开发微信小程序时，难免要用到字体图标，而微信小程序的样式中是不能直接写本地的的图标文件地址，只能用线上绝对地址或转为bese64，这点很不方便。网上找来了一篇《使用阿里图标为例子讲解如何在微信小程序中使用字体图标》。第一步：下载需要的字体图标进入阿里图标官网http://iconfont.cn/搜索自己想要的图标，如这里需要一个购物车的图标，流程为：搜索“购物车”图标—>点击“添加入库”–>点击购物车进入购物车–>点击下载代码按钮。点击下载代码，将得到名为download.zip的压缩包，解压将看到以下内容：第二步：转换ttf文件进入https://transfonter.org/平台，将解压出来的ttf字体文件转化成base64格式。流程如下：点击下载，得到转换后的压缩包，名为transfonter.org-开头。解压可以得到如下图的几个文件：第三步：在微信小程序中使用新建微信小程序，将默认生成的代码删除。1–在index.css文件中添加样式内容。打开刚刚我们经过转换的解压出来的文件，找到stylesheet.css，将其中的内容全部复制到index.css文件中。注意是转换过的那个文件。2–打开没有转换过的download.zip解压出来的文件，找到iconfont.css文件，将这个文件中的没有打岔的内容复制到index.css文件中。@font-face这部分不要，只要下边的这部分。3–在index.wxml中使用字体图标。代码如下：<!–index.wxml–><view class=”container”>个人中心<text class=”iconfont icon-wode” style=”font-size:50px;color:red”></text></view>效果如下：字体图标跟字体一样，可以通过font-size来改变大小，通过指定color来改变他的颜色。总结：到这里微信小程序的字体图标的使用就完成了，这里经过转换成64位编码之后，直接将样式放在css文件中即可，并不需要引入其他以外的文件，相当简洁。声明，本文来源于：https://blog.csdn.net/nongweiyilady/article/details/74244362"}
{"title": "微信小程序转化为uni-app项目 ", "author": "Rolan", "pub_time": "2020-3-10 00:47", "content": "前言：之前自己做一个uni-app的项目的时候前端需要实现一个比较复杂的动态tab和swiper切换的功能，但是由于自己前端抠脚的原因没有写出来，然后自己在网上搜索的时候发现了有个微信小程序里面的页面及极其的符合我的需求。那么问题来了我该如何将微信小程序转为为uni-app项目呢？搜索了下网上的相关解决方案还真有个将微信小程序转化为uni-app的项目，该项目名称叫做【 miniprogram-to-uniapp 】，接下来就看看如何实操吧！miniprogram-to-uniapp项目介绍：概要介绍：是一个能够将微信项目转化为Uni-app项目的开源项目github地址： https://github.com/zhangdaren/miniprogram-to-uniapp使用指南： https://ask.dcloud.net.cn/article/36037第一步、在window上安装NPM包管理工具：由于该项目需要使用NPM包管理工具安装对应的项目包，而NPM是随同NodeJS一起安装的包管理工具，所以接下来我们只需要把node.js安装配置好即可。Node.js 安装配置详细教程： https://www.runoob.com/nodejs/nodejs-install-setup.html第二步、初始化一个NPM模块：首先查看NPM版本：在任意盘中新建一个空白文件夹，用于存放NPM初始化模块配置：使用CMD进入对应的文件夹输入：npm init命令即可第三步、使用miniprogram-to-uniapp将微信小程序转化uni-app实例：首先下载需要转化的微信小程序：为了示范随便下载了一个微信小程序商城，项目地址为： https://github.com/hanxue10180/shangcheng下图为微信小程序的基本结构：安装miniprogram-to-uniapp，并将小程序转化为uni-app项目：因为这个包是工具，要求全局都能使用，所以需要-g进行全局安装，运行以下命令进行安装：npm install miniprogram-to-uniapp -g安装完成，执行以下命令查看工具版本：（wtu -> 取自wx to uni之意，后面都用这个全局命令）wtu -V运行以下命令将微信小程序转化为uni-app项目：在命令行里，输入【wtu -i \"你的小程序项目路径\"】，注意-i后面有个空格！！！如：【wtu -i \"G:\\shangcheng\"】 ；\r\n\r\n回车后即可以在源项目同及目录得到一个后缀为_uni的目录，即转换成功。\r\n见下图：大功告成，顺利转化为uni-app项目结构："}
{"title": "微信小程序中使用echarts以及踩坑总结（附源码） ", "author": "Rolan", "pub_time": "2020-3-16 00:08", "content": "人在家中坐，锅从天上来。半个月前本来在家写着一个项目，还没来得及提测，领导突然一个电话，需要立刻去支援另一个项目，一打听，一个烂尾半年的项目，纵使内心不愿意，还是要去啊。因为鲁迅说过，生活就像强奸，既然不能反抗，那就好好享受吧。这个项目分为PC端、用户端小程序和商家端小程序，这里主要讲讲在商家端中的某个模块，需要用到数据统计图表，当时觉得有两个插件不错：百度 echarts阿里 AntV因为之前在项目中使用 echarts 比较多，所以最终选择了 echarts 作为项目中的图表插件。echarts的引入我是按照 echarts 官网教程来引入的，很简单，不多说。 传送门echarts中使用多个图表wxml代码如下：<!--图表1-->\r\n<view class=\"echarts-container\" hidden=\"{{!isShoweyes || !echartsData.totalRecentRansactions.allTotalMoney}}\">\r\n    <ec-canvas id=\"mychart-dom-turnover\" canvas-id=\"mychart-turnover\" ec=\"{{ turnoverEc }}\"></ec-canvas>\r\n</view>\r\n<!--图表2-->\r\n<view class=\"echarts-container\" hidden=\"{{!isShoweyes || !echartsData.shopNewCustomerRespVo.allNewCustomer}}\">\r\n    <ec-canvas id=\"mychart-dom-customer\" canvas-id=\"mychart-customer\" ec=\"{{ customerEc }}\"></ec-canvas>\r\n</view>\r\n<!--图表3-->\r\n<view class=\"echarts-container\" hidden=\"{{!isShoweyes || !echartsData.customerOrderAverageRespVo.customerAverage}}\">\r\n    <ec-canvas id=\"mychart-dom-price\" canvas-id=\"mychart-price\" ec=\"{{ priceEc }}\"></ec-canvas>\r\n</view>js代码如下<!--通过lazyLoad设置图表懒加载-->\r\ndata: {\r\n    isShoweyes: true,\r\n    turnoverEc: {\r\n      lazyLoad: true,\r\n    },\r\n    customerEc: {\r\n      lazyLoad: true,\r\n    },\r\n    priceEc: {\r\n      lazyLoad: true,\r\n    },\r\n    echartsData: {}\r\n  },\r\n  \r\n<!--页面加载时创建对应的canvas面板-->\r\nonLoad: function (options) {\r\n    this.echartsComponnet1 = this.selectComponent('#mychart-dom-turnover');\r\n    this.echartsComponnet2 = this.selectComponent('#mychart-dom-customer');\r\n    this.echartsComponnet3 = this.selectComponent('#mychart-dom-price');\r\n  },\r\n  <!--获取到数据后，初始化报表-->\r\n  getData: function () {\r\n    //  .... 获取数据\r\n    \r\n    <!--此用循环初始化几个图表-->\r\n    for (let i = 1; i < 4; i++) {\r\n        if (!Chart[i]) {\r\n          this.initEcharts(i); //初始化图表\r\n        } else {\r\n          this.setOption(i); //更新数据\r\n        }\r\n      }\r\n  },\r\n  <!--//初始化图表-->\r\n  initEcharts: function (i) {\r\n    this['echartsComponnet' + i].init((canvas, width, height) => {\r\n      // 初始化图表\r\n      Chart[i - 1] = echarts.init(canvas, null, {\r\n        width: width,\r\n        height: height\r\n      });\r\n      this.setOption(i);\r\n      // 注意这里一定要返回 chart 实例，否则会影响事件处理等\r\n      return Chart[i - 1];\r\n    });\r\n  },\r\n  setOption: function (i) {\r\n    Chart[i - 1].clear(); // 清除\r\n    Chart[i - 1].setOption(this['getOption' + i]()); //获取新数据\r\n  },\r\n  \r\n  <!--设置报表需要的配置项-->\r\n  getOption1() {\r\n    let {\r\n      echartsData\r\n    } = this.data;\r\n    return {\r\n      color: ['#0179FF'],\r\n      tooltip: {\r\n        trigger: 'axis',\r\n        axisPointer: { // 坐标轴指示器，坐标轴触发有效\r\n          type: 'shadow', // 默认为直线，可选为：'line' | 'shadow'\r\n          shadowStyle: {\r\n            opacity: 0.8\r\n          }\r\n        },\r\n        formatter: this.formatterTooltip,\r\n        position: this.setTooltipPositionfunction\r\n      },\r\n      grid: {\r\n        left: 20,\r\n        right: 20,\r\n        bottom: 15,\r\n        top: 40,\r\n        containLabel: true\r\n      },\r\n      xAxis: [{\r\n        type: 'category',\r\n        axisLine: {\r\n          lineStyle: {\r\n            color: '#999',\r\n          }\r\n        },\r\n        axisLabel: {\r\n          color: '#666',\r\n        },\r\n        data: echartsData.totalRecentRansactions.dates,\r\n      }\r\n      ],\r\n      yAxis: [{\r\n        type: 'value',\r\n        axisTick: {\r\n          show: false\r\n        },\r\n        axisLine: {\r\n          show: false,\r\n          lineStyle: {\r\n            color: '#999',\r\n          }\r\n        },\r\n        axisLabel: {\r\n          color: '#666',\r\n          fontSize: 13\r\n        }\r\n      }],\r\n      series: [{\r\n        name: '订单总额',\r\n        type: 'line',\r\n        label: {\r\n          normal: {\r\n            show: true,// 是否在折线点上显示数值\r\n            position: 'inside'\r\n          }\r\n        },\r\n        data: echartsData.totalRecentRansactions.allTotalMoney\r\n      }]\r\n    };\r\n  }遇到的坑1.Tooltip支持不好虽然官网上echarts暂时不支持 Tooltip ，但是经过试验，还是 Tooltip 还是有效果的，但是，x轴对应的坐标值并不会显示在 Tooltip 中，需要使用 Tooltip 的 formatter 函数，自己处理需要展示的数据，代码如下：// 格式化Tooltip\r\n  formatterTooltip(param) {\r\n    return \"日期：\" + param[0].name + \"\\n\" + param[0].seriesName + \": \" + param[0].data\r\n  },2.当点击靠近屏幕右侧或者底部的item项时， Tooltip 会溢出边界，解决办法：给 Tooltip 的 position 函数返回一个根据点击位置计算的坐标点，（也可以给一个固定的位置，但是体验不好）// 更改Tooltip的位置，处理边界超出的情况\r\n  setTooltipPositionfunction(point, params, dom, rect, size) {\r\n    //其中point为当前鼠标的位置，size中有两个属性：viewSize和contentSize，分别为外层div和tooltip提示框的大小\r\n    // 更改提示框的显示位置\r\n    let x = point[0];//\r\n    let y = point[1];\r\n    // size: 包括 dom 的尺寸和 echarts 容器的当前尺寸，例如：{contentSize: [width, height], viewSize: [width, height]}\r\n    let boxWidth = size.contentSize[0];\r\n    // let boxHeight = size.contentSize[1]; // size里面此处获取不到dom的高度，值为NAN，所以下面指定了一个固定值\r\n    let boxHeight = 50;\r\n    let posX = 0;//x坐标位置\r\n    let posY = 0;//y坐标位置\r\n    if (x < boxWidth) {//左边放不开\r\n      posX = 5;\r\n    } else {//左边放的下\r\n      posX = x - boxWidth;\r\n    }\r\n\r\n    if (y < boxHeight) {//上边放不开\r\n      posY = 5;\r\n    } else {//上边放得下\r\n      posY = y - boxHeight;\r\n    }\r\n    return [posX, posY];\r\n  },上面需要注意的是，获取 dom 的高度，官方上说的是可以从 position 回调函数的 size 参数中获取到 dom 的高度，但是我打印出来却是 NAN 。打印出来结果：后来发现参数 params 中 outerWidth 的值和参数 size 中 contentSize 的宽度值相同，所以果断取参数 params 中的 outerHeight 作为 dom 的高度，最后运行的效果确实没有问题。3.左右滑动柱状图时，柱状图画板会变空白，点一下空白又会出现柱状图，而且这个问题只有在柱状图上出现！刚开始以为是自己代码的问题，后来自己检查了几遍，确实没什么问题，然后扫码体验了官方的小程序demo，发现也有这个问题，顿时只想对它口吐芬芳。既然是官方代码自身的问题，于是去看了下源码，如下：<canvas class=\"ec-canvas\" canvas-id=\"{{ canvasId }}\" bindinit=\"init\" bindtouchstart=\"{{ ec.disableTouch ? '' : 'touchStart' }}\" bindtouchmove=\"{{ ec.disableTouch ? '' : 'touchMove' }}\" bindtouchend=\"{{ ec.disableTouch ? '' : 'touchEnd' }}\"></canvas>官方代码给画布绑定一个 bindtouchmove 事件touchMove(e) {\r\n      if (this.chart && e.touches.length > 0) {\r\n        var touch = e.touches[0];\r\n        var handler = this.chart.getZr().handler;\r\n        handler.dispatch('mousemove', {\r\n          zrX: touch.x,\r\n          zrY: touch.y\r\n        });\r\n        handler.processGesture(wrapTouch(e), 'change');\r\n      }\r\n    },这里面又去调用了 echarts.js 中的方法，最后想了一个粗暴的解决办法：删掉源码中的bindtouchmove事件完美解决，哈哈或或红红火火恍恍惚惚~~~以上就是我在小程序中使用echarts遇到的坑，希望能帮到后来踩坑的人。最终效果图片Demo源码点 这 里"}
